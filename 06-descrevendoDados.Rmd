# Descrevendo os dados  

Nos relatórios ou artigos científicos, a comunicação dos resultados é feita através da combinação de medidas resumidoras e visualização dos dados por meio de tabelas e gráficos.

## Pacotes necessários neste capítulo

Para trabalhar neste capítulo, serão necessários os seguintes pacotes. 

```{r}
pacman::p_load(dplyr, 
               ggplot2, 
               ggpubr, 
               ggsci, 
               grDevices, 
               Hmisc, 
               kableExtra, 
               knitr, 
               plotrix, 
               readxl, 
               scales)
```

## Dados brutos  

Habitualmente, costuma-se armazenar os dados em bancos de dados (*dataframes* ou *tibbles*). Entretanto, eles estão registrados de forma aleatória e não classificada. Ao se visualizar um dataframe, é difícil responder perguntas em relação a qualquer variável, principalmente, em grandes banco de dados. Eles se constituem uma lista, um rol de valores colocados na ordem em que foram obtidos. Parecem um jogo de quebra cabeça antes de serem organizados e resumidos! São denominados de *dados brutos* ou, também, de dados não agrupados. 

```{r babel, echo = FALSE, out.width = '70%', fig.align = 'center', fig.cap="Quebra-cabeça da Torre de Babel (pintura de Pieter Bruegel, 1563)", fig.pos="H"}
 knitr::include_graphics("https://imgur.com/MrhPiiG.png") 
```

## Medidas resumidoras

### Dados usados nesta seção

Para a demonstração prática será usado um conjunto de dados que é uma amostra aleatória de 15 recém-nascidos do banco de dados `dadosMater.xlsx` (ver Seção \@ref(sec-mater)), extraída com a função `slice_sample()` do pacote `dplyr`. Cada vez que este comando for reproduzido, retornará uma nova série de 15 valores diferentes do anterior. Para tornar o código reproduzível, retornando o mesmo conjunto de valores, deve-se usar uma “semente” (`seed`), usando a função `set.seed()`, cujo argumento é um número que identificará a série gerada. 
Após extrair a amostra, serão selecionadas as variáveis usadas nesta seção. A amostra será atribuída a um objeto denominado, `dados`:

```{r}
set.seed(1234) 
dados <- readxl::read_excel("Arquivos/dadosMater.xlsx") %>% 
  filter(ig>= 37 & ig<42) %>% 
  select(idadeMae, anosEst, pesoRN, apgar1) %>% 
  slice_sample(n=15)
str(dados) 
```

Após a manipulação dos dados, tem-se um *tibble* de 15 linhas e quatro colunas.

### Introdução

Sempre que se está diante de um novo conjunto de dados para analisar, uma das primeiras tarefas é encontrar maneiras de resumir os dados de forma compacta e fácil de entender. Este processo se constitui na **estatística descritiva** que compreende métodos de tabulação, gráficos e resumo dos dados.
Nesta seção, serão verificadas as medidas de resumo dos dados de duas maneiras:  

*	Primeiro, um valor em torno do qual os dados têm uma tendência para se reunir ou se agrupar, denominado de **medida sumária de localização** ou **medida de tendência central**.
*	Em segundo lugar, um valor que mede o grau em que os dados se dispersam, denominado de **medida de dispersão** ou **variabilidade**

### Medidas de tendência central
#### Média

A média ( $\overline{x}$ ) é a mais usada medida de tendência central para representar um valor típico ou central dentro de um conjunto de números. O conceito mais comum é a **média aritmética**, que se calcula somando todos os valores do conjunto e dividindo pelo número total de elementos. A média é mais adequada para medidas numéricas simétricas.

$$
\overline{x}= \frac{\sum(x_1 + x_2 + x_3 + ... + x_n)}{n}
$$

O *R* base possui uma função para o cálculo da média – `mean()`, apresentada  a Seção \@ref(sec-funcoes), onde foi mostrado os seus argumentos. Se a variável analisada contiver algum valor ausente (`missing`), deve-se usar o argumento `na.rm = TRUE`, para removê-los, pois, caso contrário, a função retorna um resultado como NA (*Not Available*). Para evitar transtornos, recomenta-se usar sempre o argumento. 

```{r}
mean (dados$pesoRN, na.rm = TRUE)
```
  
Para reduzir o número de dígitos decimais, na saída do resultado, pode-se colocar a função `mean()`, dentro da função `round()`^[Usa-se esta sintaxe: `round(x, digits = 0)`, onde `x` é o numero que se quer arredondar e `digits` é número de casas decimais. O padrão é `0`, ou seja, arredonda para o inteiro mais próximo.], atribuindo o resultado da função a um objeto, por exemplo `media`. 

```{r}
media <- round(mean (dados$pesoRN, na.rm = TRUE), 1)
print(media)
```

Ou,usar a função `round()` separadamente: 

```{r}
media <- mean (dados$pesoRN, na.rm = TRUE)
round(media, 1)
```

#### Mediana

A mediana (Md) representa o valor central em uma série ordenada de valores. Assim, metade dos valores será igual ou menor que o valor mediano e a outra metade igual ou maior do que ele.  
No R, usa-se a função `median()` para calcular o valor da mediana. Vanos utilizar a variável `dados$apgar1`. Como o Apgar é um escore, a medida resumidora mais adequada é a mediana. 

```{r}
median (dados$apgar1, na.rm = TRUE)
```

#### Moda

Moda (Mo) é o valor que ocorre com maior frequência em um conjunto de dados. Tem o menor nível de sofisticação. É usada primariamente para dados nominais porque há simplesmente contagem dos valores. Ao contrário das outras medidas de tendência central, a moda não informa nada sobre a ordem das variáveis ou variação dentro das variáveis.  
O R não tem uma função embutida padrão para calcular a moda. Portanto, há necessidade de ser criada uma função de usuário para calcular a moda.  

```{r}
moda <- function(x) {
  z <- table(as.vector(x))
  names(z)[z == max(z)]}
```

UEsta função `moda()` deve ser salva em seu diretório, na pasta das suas funções próprias. Quando necessário ela pode ser acessada como foi visto na seção sobre criação de funções.  Será calculada a moda da variável dados$apgar1.

```{r}
moda (dados$apgar1) 
```

#### Quantil

Uma medida de localização bastante utilizada são os **quantis** que são pontos estabelecidos em intervalos regulares que dividem a amostra em subconjuntos iguais. Se estes subconjuntos são em número de 100, são denominados de **percentis**; se são em número de 10, são os **decis** e em número de 4, são os **quartis**. 
A função apropriada no R para obter o quantil é `quantile()`.   

Para determinar os três quartis do peso dos recém-nascidos (`mater15$pexoRN`), usa-se:

```{r}
quantile (dados$pesoRN, c (0.25, 0.50, 0.75))
```

Observe que o percentil 50º é igual a mediana. O percentil 75º é o ponto do conjunto de dados onde 75% dos recém-nascidos têm um peso inferior a `r quantile (dados$pesoRN, 0.75)`g e 25% está acima deste valor.

#### Média aparada

As médias aparadas são estimadores robustos da tendência central. Para calcular uma média aparada, é removida uma quantidade predeterminada de observações em cada lado de uma distribuição e realizada a média das observações restantes. Um exemplo de média aparada é a própria mediana.   

A base R tem como calcular a média aparada acrescentando o argumento `trim =`, proporção a ser aparada. Se for aparado 20%, usa-se `trim = 0.2`. isto significa que serão removidos 20% dos dados dos dois extremos. No caso da amostra de 15 recém-nascidos, serão removidos três valores mais baixos e três valores mais altos, passando a mostra a ter 9 valores, e a média aparada será a média destes 9 valores.   

O comando para obter a média aparada é:

```{r}
mean (dados$pesoRN, na.rm = TRUE, trim = 0.20)
```

### Medidas de Dispersão

#### Amplitude  

A amplitude de um grupo de medições é definida como a diferença entre a maior observação e a menor.  
No conjunto de dados dos pesos dos recém-nascidos, a amplitude pode ser obtida, no R, com a função `range()`, que retorna o valor mínimo e o máximo.

```{r}
range (dados$pesoRN, na.rm = TRUE)
```

#### Intervalo Interquartil
      
A intervalo interquartil (IIQ), também conhecido como amplitude interquartil (AIQ) é uma forma de média aparada. É simplesmente a diferença entre o terceiro e o primeiro quartil, ou seja, a diferença entre o percentil 75 e o percentil 25. Considere a escolaridade (`dados$anosEst`), anos de estudos completos.   

Os percentis 25 e 75 são obtidos, usando a função `quantile()`, vista acima, ou com a função `summary()` , que retorna os valores mínimo, primeiro quartil, mediana, média terceiro quartil e máximo.


```{r}
quantile (dados$anosEst, c(0.25,0.75))
```


```{r}
summary(dados$anosEst)
```

Portanto, o IIQ está entre 6,5 a 11 anos de estudo ou, 11 – 6,5 = 4,5 anos de estudos completos. Em outras palavras, 50% das mulheres desta amostra têm de 6 a 8 anos de estudo.

O *R* possui uma função específica para calcular o intervalo interquartil, denominada `IQR()` e incluída no pacote `stats`, pertencente ao `R` base. Ela possui os seguintes argumentos:

**x** $\longrightarrow$ Representa o vetor numérico;
**na.rm** $\longrightarrow$ Este assume um valor lógico, TRUE ou FALSE, indicando se os valores ausentes devem ser removidos ou não;
**type** $\longrightarrow$ Representa um número inteiro selecionando um dos muitos algoritmos de quantil. Este é um parâmetro opcional.

```{r}
IQR(dados$anosEst, na.rm = TRUE)
```


#### Variância e Desvio Padrão {#sec-variancia}

A variância e o desvio padrão fornecem uma indicação de quão aglomerados em torno da média os dados de uma amostra estão. Estes tipos de medidas representam desvios (erros)da média. Quando se verifica o desvio de cada valor (x) em relação à média $\overline{x}$, os desvios positivos se anulam com os negativos, resultando em uma soma igual a zero.   

A consequência deste fato é que não é possível resumir os desvios numa única medida de variabilidade. Para se chegar a uma medida de variabilidade há necessidade de se eliminar os sinais, antes de somar todos os desvios em relação à média.   

Uma maneira de se fazer isso é elevar todas as diferenças ao quadrado. Assim, se obtém o desvio em relação à média elevado ao quadrado. A soma destes valores é denominada de *Soma dos Quadrados (SQ) dos Desvios* ou *Soma dos Erros ao Quadrado*. Se o interesse é apenas saber o erro ou desvio médio, divide-se por *n* (tamanho da amostra). No entanto, em geral o interesse se concentra em usar o desvio ou erro na amostra para estimar o erro na população. Dessa maneira, divide-se a Soma dos Quadrados por $n-1$. Essa medida é conhecida como variância ($s^2$). O divisor, $n – 1$, é denominado de *graus de liberdade* (gl) associados à variância.

Os graus de liberdade representam o número de desvios que estão livres para variar. É um conceito de difícil explicação. Suponha uma maternidade há 50 anos atrás, quando não havia alojamento conjunto. Nessa época era comum os recém-nascidos normais ficarem em um berçário. A cada horário de amamentação eles eram levados para os quartos de suas mães para mamar. Posteriormente, eram trazidos para o berçário e colocados nos berços até a próxima mamada. Suponha que, em um determinado momento, havia 15 bebês e que, no berçário, existiam 15 berços (postos) para colocá-los durante o intervalo das mamadas. Quando o primeiro recém-nascido chega, a enfermeira poderá escolher qualquer um dos berços para o colocar. Depois, quando o próximo recém-nascido chegar, ela terá 14 opções de escolha, pois um dos berços está ocupado. Ainda existe uma boa liberdade de escolha. No entanto, à medida que os recém-nascidos forem sendo trazidos para o berçário, chegará a um ponto em que 14 berços estarão ocupados. Agora, a enfermeira não terá liberdade de escolha, pois só resta um berço. Nesse exemplo existem 14 graus de liberdade. Para o último recém-nascido não houve liberdade de escolha @field2012df. Portanto, os graus de liberdade são iguais ao tamanho da amostra menos um ($n-1$).

A variância é a razão entre a soma dos quadrados e as observações realizadas menos um. 

$$
s^2= \frac{\sum(x_i - \overline{x})^2}{n-1}
$$

No R existem as funções `sd()` e `var()`, também incluídas no R base, que facilmente calculam essas medidas de dispersão.   

Usando a variável `dados$pesoRN`, tem-se:

```{r}
var(dados$pesoRN, na.rm =TRUE)
```

O desvio padrão é a raiz quadrada da variância: $s = \sqrt var$

```{r}
sqrt (var(dados$pesoRN))
```

Ou,

```{r}
sd (dados$pesoRN, na.rm = TRUE)
```

A variância e desvio padrão são medidas de variabilidade. Representam quão bem a média representa os dados. Informa se ela está funcionando bem como modelo. Pequenos desvios padrão mostram que existe pouca variabilidade nos dados, que eles se aproximam da média. Quando existe um grande desvio padrão, a média não é muito precisa para representar os dados.   

O desvio padrão, além de medir a precisão com que a média representa os dados, também informa sobre o formato dos dados e por isso é uma medida de dispersão. Em uma amostra onde desvio padrão é pequeno, os dados se agrupam próximo a média e o formato da distribuição fica mais pontiagudo (curva em azul, \@ref(fig:dispersao)). Nesse caso a média representa bem os dados. Em outra amostra, com a mesma média anterior, mas com os dados mais dispersos entorno da média, o desvio padrão é maior e o formato da distribuição fica achatado (curva verde, na Figura \@ref(fig:dispersao)). Nesse caso a média não é uma boa representação dos dados.

```{r dispersao, echo=FALSE, message=FALSE, fig.align = 'center',  fig.cap="Dispersão dos dados em torno da média.", fig.pos="H"}
curve (dnorm (x, 
              mean=0, 
              sd=0.7), 
       col="steelblue", 
       lty=1,
       lwd=2,
       ylim = c(0, 0.6),
       xlim = c(-3.5, 3.5),
       ylab = "Densidade",
       xlab = "X",
       bty = "n")
box(bty = "L")
abline (v= 0, lwd = 2, lty = 2, col = "red")

curve (dnorm (x, 
              mean=0, 
              sd=1.3), 
       col="green3", 
       lty=1,
       lwd=2,
       add=T)
```


#### Coeficiente de Variação

O desvio padrão por si só tem limitações. Um desvio padrão de duas unidades pode ser considerado pequeno para um conjunto de valores cuja média é 100. Entretanto, se a média for 5, ele se torna muito grande. Além disso, o desvio padrão por ser expresso na mesma unidade dos dados, não permite aplicá-lo na comparação de dois ou mais conjunto de dados que têm unidades diferentes.
Para eliminar essas limitações, é possível caracterizar a dispersão ou variabilidade dos dados em termos relativos, usando uma medida denominada Coeficiente de Variação (CV), também conhecido como como *Desvio Padrão Relativo* ou *Coeficiente de Variação de Pearson*. É expresso, em geral como uma porcentagem, sendo definido como a razão do desvio padrão pela média:

$$
CV = \frac{s}{\overline{x}}
$$

Multiplicando o valor da equação por 100 tem-se o CV percentual. O R não possui uma função específica para calcular o CV.   

Foi criada uma função específica para isso,já multiplicada por 100.

```{r}
coef_var <- function (valores) {
  (sd(valores, na.rm=TRUE) / mean(valores, na.rm=TRUE))*100}
```

Portanto, o CV da variável `dados$pesoRN` é igual a:

```{r}
coef_var (dados$pesoRN)
```

Se usarmos outra variável do banco de dados, por exemplo, `dados$idadeMae`, o CV será igual a:

```{r}
coef_var (dados$idadeMae)
```

O peso do recem-nascido tem um CV = `r round(coef_var (dados$pesoRN), 1)` e a idade materna um CV = `r round(coef_var (dados$idadeMae), 1)`, mostrando que esta tem uma maior variabilidade. Quanto menor o desvio padrão, menor o CV e, consequentemente, menor a variabilidade. Um CV $\ge$ 50%, sugere que a variável tem uma distribuição assimétrica.  

### Escolha da medida resumidora

A seleção da medida de tendência central mais adequada depende de vários fatores, incluindo a natureza dos dados e do propósito da sumarização.  

O tipo da variável tem substancial influência na escolha da medida de tendência central a ser usada. A moda é mais apropriada para dados nominais e seu uso com variáveis ordinais resulta em uma perda no poder em termos de informação que se poderia obter dos dados.  

A mediana é mais adequada para variáveis ordinais, embora possa ser usada para variáveis contínuas, especialmente quando a distribuição dos dados é assimétrica. A mediana não deveria ser usada com dados nominais porque os postos assumidos não podem ser obtidos com dados de nível nominal.  

Finalmente, a média somente deve ser usada com dados contínuos simétricos, se houver assimetria a mediana deve ser preferida.

As medidas de dispersão devem estar associadas a uma medida de tendência central. Elas caracterizam a variabilidade dos dados na amostra. Com dados ordinais usar a amplitude ou o intervalo interquartil. O desvio padrão não é apropriado em dados ordinais devido à natureza não numérica destes.  

Com os dados numéricos deve-se usar o desvio padrão, que utiliza toda a informação nos dados, ou o intervalo interquartil (IIQ). Quando os dados forem simétricos, usar a média acompanhada do desvio padrão, caso contrário, usar a mediana e o IIQ. Não misturar e combinar medidas [@bowers2008scratch].  

## Tabelas 

A apresentação tabular dos dados é a apresentação das informações por meio de tabelas. Uma tabela é uma forma eficiente de mostrar os dados levantados, facilitando a sua compreensão e interpretação. No R existem muitas maneira de criar tabelas. 

### Dados usados nesta seção

Para mostrar como construir as tabelas, será feita a leitura do conjunto de dados `dadosMater.xlsx`, mencionado na seção anterior . Como visto, este conjunto de dados contém uma grande quantidade colunas e, para tornar mais fácil a análise, serão selecionadas aquelas utilizadas nesta seção.

```{r}
mater <- readxl::read_excel("Arquivos/dadosMater.xlsx") %>% 
   select(idadeMae, altura, peso, anosEst, fumo, 
           para, ig, sexo, pesoRN, compRN, utiNeo)

str(mater)
```

### Tabelas de Frequência  {#sec-freq}

#### Tabela de frequência para dados categóricos

Uma maneira concisa que permite observar a variável e extrair informação sobre o seu comportamento, é a utilização de uma *tabela de frequência*. A tabela de frequência deve ser simples, clara e objetiva, ou seja, não deve ter um volume muito grande de informações. Deve ser autoexplicativa, não deve haver necessidade de ler o texto para entendê-la.   

A tabela de frequência agrupa os dados por categorias ou classes, contabilizando o número ocorrências em cada categoria. O número de observações em uma determinada classe recebe o nome de *frequência absoluta* (*f*). Além da frequência absoluta, costuma aparecer a frequência relativa (*fr*) que representa a proporção da classe em relação ao número total de observações (*n*), calculada por $fr = \frac{f}{n}$, a frequência percentual (*fp*), obtida pela multiplicação da frequência relativa por 100 e a frequência acumulada, que é a soma de todas as classes até a classe atual, podendo ser frequência acumulada absoluta (*F*), frequência acumulada relativa (*Fr*) ou frequência acumulada percentual (*Fp*).   

Em uma tabela, os dados são apresentados em colunas verticais indicadoras e linhas horizontais. Nas linhas aparecem as categorias e nas colunas as frequências, constituindo o corpo da tabela. O cabeçalho indica a natureza do conteúdo de cada coluna. No cruzamento das colunas e das linhas, tem-se as caselas ou casas.  

Existem algumas recomendações na construção de uma tabela de frequência @arango2009tab:  

* deve ter um título na parte superior que responda as perguntas: “o que? quando? onde?” relativas ao fato estudado;
* deve ter um rodapé, na parte inferior da tabela, onde se coloca notas necessárias e a fonte dos dados;
* as colunas externas da tabela devem ser abertas, o emprego de linhas verticais para a separação das colunas no corpo da tabela é opcional;
* Na parte superior e inferior, as tabelas devem, ser fechadas por linhas horizontais;
* Nenhuma casela deve ficar vazia, apresentando um número ou um símbolo. Se não se dispuser do dado, colocar reticências ... e a presença de um X representa que o dado foi omitido para evitar a identificação.

Se os dados forem nominais, a ordenação das categorias é arbitrária, costuma-se colocar em primeiro lugar a maior frequência (Tabela \@ref(tab:droga)) , colocando-os em categorias ordenadas [@oliveira2022tab].

```{r droga, echo=FALSE, warning=FALSE, message=FALSE}
df1 <- data.frame(Drogadição = c("Não drogaditas", "Medicamentos", "Álcool", 
                                 "Crack", "Cocaína", "Total"),
                  f = c(904, 23, 17, 2, 1, 947),
                  fr = c(0.955, 0.024, 0.018, 0.002, 0.001, 1.00),
                  fp = c(95.5, 2.4, 1.8, 0.2, 0.1, 100),
                  Fp = c(95.5, 97.9, 99.7, 99.9, 100, ''))

knitr::kable(df1,
             align = "lrrrr",  
             booktabs = TRUE,
             caption = "Distribuição de frequência de drogadição em parturientes do Hospital Geral de Caxias do Sul, RS, 2008.",
             format.args = list(decimal.mark = ",")) %>% 
  kableExtra::kable_classic(full_width = T, html_font = "Cambria") %>% 
  kableExtra::row_spec(0, bold = TRUE)
```

#### Construção da tabela de frequência   {#sec-tabfreq}

Para demonstrar como construir uma tabela de frequência, usando o R, será usada uma variável categórica que não existe no conjunto de dados `mater.` Esta variável vai ser criada, categorizando a variável numérica `idadeMae` (idade da parturiente) em três categoria, classicamente, usadas: menores de 20 anos (adolescentes), 20 a 35 anos e maiores de 35 anos. No conjunto mater, a variável `idadeMae` tem como idade mínima 13 anos e idade máxima 46 anos. A nova variável receberá o nome de `categIdade`.
Para realizar este trabalho de transformação da variável numérica em categórica, será usada a função `cut()` do pacote R base.
 Esta função tem vários argumentos:

* *x*      $\longrightarrow$ vetor numérico
* *breaks*     $\longrightarrow$ vetor numérico de dois ou mais pontos de corte exclusivos ou um único número (maior ou igual a 2) dando o número de intervalos nos quais *x* deve ser subdividido
* *labels*  $\longrightarrow$ rótulos para os níveis das categorias resultante. Por padrão, os rótulos são construídos usando a notação de intervalo $(a, b]$ (aberto à esquerda e fechado à direita). 
* *include.lowest*      $\longrightarrow$ valor lógico, se o menor valor será incluido, ou o maior, se `right = TRUE`. Padrão = `include.lowest=TRUE`
* *right*      $\longrightarrow$ valor lógico indicando se o intervalo deve ser fechado à direita e aberto a esquerda. Padrão = 
`right = TRUE`.
* *ordered_result* $\longrightarrow$ valor lógico indicando se o resultado deve ser um fator ordenado.  

```{r}
mater$categIdade <- cut(mater$idadeMae,
                        breaks = c(13, 20, 36, 46),
                        labels = c("<20a", "20-35a", ">35a"),
                        include.lowest = TRUE,
                        right = FALSE,
                        ordered_result =TRUE)
```

Para visualizar se a variável foi criada de maneira adequada, pode-se usar novamente a função `str()`:

```{r}
str(mater)
```

A nova variável foi gerada de forma correta. Observe que para que isso acontecesse, foi usado `right = FALSE`, em consequência, o intervalo 13 a 20, incluirá o 13 (menor idade) e excluirá o 20, o intervalo 20 a 36, incluirá o 20 e excluirá o 36 e o último intervalo incluirá o 36 e excluirá o 46, que é o valor mais alto. Em função disso, foi incluído mais um argumento `include.lowest=TRUE`, para incluir o valor 46.
Para se verificar como ficou a distribuição de frequência absoluta, constrói-se uma tabela, inicialmente com a função `table()`:


```{r}
f_abs <- table (mater$categIdade)
f_abs
```

As frequências relativas podem ser obtidas com a função `prop.table()`, Esta função será usada dentro da  função `round()` para arredondar os valores para 3 dígitos.

```{r}
f_rel <- round(prop.table(f_abs), 3)
f_rel
```

Multiplicando por 100 a `f_rel`, tem-se a frequência percentual `f_perc`. De novo, a operação será colocada dentro da função `round()`, arredondando o resultado para dois dígitos.

```{r}
f_perc <- round(f_rel*100, 2)
f_perc
```
Para construir uma tabela simples no R, pode-se proceder da seguinte maneira:

```{r}
# Criando as colunas das tabelas com o total de cada uma delas
f_abs <- c (f_abs, sum(f_abs))
f_rel <- c (f_rel, sum (f_rel))
f_perc <- c (f_perc, sum (f_perc))

# Criando a tabela inicial com a concatenação das coluna - função cbind()
tab1 <- cbind(f_abs,
              f_rel ,
              f_perc)
tab1
```

Transformando a tab1 em um dataframe, nomeando a linha 4 e renomeando as colunas para ficar com os nomes referidos no início da seção:

```{r}
tab1 <- as.data.frame(tab1)
row.names(tab1)[4] <-  "Total"
colnames(tab1) <- c("f", "fr", "fp")
tab1
```


Esta uma tabela simples que serve para visualizar as informações. Não serve para publicações. Para obter uma tabela simples, mas muito mais profissional (Tabela \@ref(tab:tisch)) pode ser utilizada a função `kable()` do pacote `knitr` @xie2018knitr. Esta função possui um grande número de argumentos para personalizar a aparência das tabelas^[Para maiores detalhes: https://haozhu233.github.io/kableExtra/awesome_table_in_pdf.pdf ou consulte a ajuda digitando no Console `?kable()` ou `help(kable)`.]:

*	*x* $\rightarrow$ é um objeto do R, tipicamente uma matiz ou dataframe;
*	*format* $\rightarrow$ sequência de caracteres. Os valores possíveis são ”latex”, “html”, “pipe”, “simple”; 
*	*digits* $\rightarrow$ número máximo de dígitos para colunas numéricas, passado para `round()`;
*	*row.names* $\rightarrow$lógico: se deve incluir nomes de linhas. Por padrão, os nomes de linhas serão incluídos se rownames(x) não for NULL nem idêntico a `1:nrow(x)`.
*	*col.names* $\rightarrow$ vetor de caracteres de nomes de colunas a serem usados na tabela.;
*	*align* $\rightarrow$ alinhamento da coluna: um vetor de caracteres que consiste em “l” (esquerda), “c”' (centro) e/ou “r” (direita). Por padrão ou se `align = NULL`, as colunas numéricas são alinhadas à direita e as outras colunas são alinhadas à esquerda.; 
*	*caption* $\rightarrow$ título da tabela;
*	... $\rightarrow$ outros argumentos

Um pacote adicional, `kableExtra` @zhu2021construct, permite opções de formatação simples, melhorando o aspecto da tabela, utilizando-se o operador pipe %>%. O pacote `kableExtra` foi projetado para estender a funcionalidade básica das tabelas produzidas usando `knitr::kable()`. Podem ser acrescentadas várias das suas funções como `kable_styling()` ou `kable_classic()` para especificar estilos à tabela, como extensão da tabela, alinhamento, tipo e tamanho da fonte ^[Consulte https://cran.r-project.org/web/packages/kableExtra/kableExtra.pdf].

```{r tisch, echo=TRUE, warning=FALSE, message=FALSE}
knitr::kable(tab1,
             booktabs = TRUE,
             caption = "Distribuição das puérperas por faixa etária, Hospital Geral de Caxias do Sul, RS, 2008.",
             format.args = list(decimal.mark = ",")) %>% 
kableExtra::kable_classic_2(full_width = FALSE, 
                            html_font = "Cambria",
                            position = "center") %>% 
kableExtra::row_spec(0, bold = TRUE) %>% 
   kableExtra::column_spec(1:4, 
                           width = "2.5cm")
```

#### Tabela de frequência para dados numéricos

Como fazer a distribuição de frequência de uma variável contínua sem um critério pré-determinado para as classes?   

Como exemplo, será usado, agora, o IMC pré-gestacional das parturientes do banco de dados `dadosMater.xlsx`). Esta variável não existe, tem-se apenas o peso e a altura e, portanto, com estes dados, ela pode ser criada:

```{r}
mater$imc <- round(mater$peso/mater$altura^2, 1)
str(mater)
```

A variável `imc` foi criada de forma adequada. Essa variável foi construida por questões didáticas como exercício de manipulação dos dados no R. 
Bem!  Após, isso, para verificar a sua distribuição, segue-se os seguintes passos:

1. _Estabelecimento do número de classes (k)_:  

Antes, as classes foram estabelecidas de acordo com algum critério. Em geral, quando não há um padrão pré-determinado, o número de classes é estabelecido de acordo com o tamanho da amostra. Este número pode ser escolhido lembrando-se das oscilações que ocorrem nos dados e do interesse do pesquisador em mostrar seus dados. Não existe uma regra totalmente eficiente para determinar o número de classes. É importante ter bom senso, de maneira que seja possível ver como os valores se distribuem.   

Para a maioria dos dados, é recomendado e 8 a 20 classes, isto é, 8 $\le$ k $\le$ 20. Com poucas classes, perde-se precisão e, com muitas classes, a tabela torna-se muito extensa. Baseado na regra de Sturges , é sugerido usar a recomendação da Figura \@ref(fig:sturges) [@arango2009classes].   


```{r sturges, echo = FALSE, out.width = '70%', fig.align = 'center', fig.cap="Número de classes baseado em Sturges", fig.pos="H"}
 knitr::include_graphics("https://i.imgur.com/IXn5SNz.png")
```

Para a variável `imc`, como existem 1368 observações, deve-se usar ao redor de 10 classes. Executando a função `nclass.Sturges ()`, abaixo, o número de classes é igual a:

```{r}
k <- nclass.Sturges (mater$imc)
k
```

2. _Amplitude e limites das classes_:  

A classe possui um limite inferior e um limite superior. O importante é que os limites dos intervalos sejam mutuamente exclusivos, isto cada valor deve ser representado em um único intervalo. Além disso, os intervalos devem ser exaustivos, isto é, devem conter todos os valores possíveis entre o valor mínimo e o máximo. O recomendado é que as classes sejam homogêneas, ou seja, tenham a mesma amplitude. A amplitude dos valores pode ser obtida com a função `range()`: 

```{r}
amplitude <- range(mater$imc) 
amplitude 
```

Usando esta amplitude dos dados, é possível ter a largura (amplitude) das classes (`h`), usando a diferença entre o mínimo e máximo e divdindo pelo número de clsasses (`k`):

```{r}
h <- round(diff(amplitude)/k, 0)
h
```

A fórmula é apenas a diferença absoluta dos limites inferior e superior dividida pelo número de classes, arredondado com o a função round () com 1 dígito decimal.   

A partir desses dados, é possível construir as classes. A primeira classe será o valor mínimo de 11,8, que pode ser arredondado para 11,8 até 14,8 (11,8 + 3) exclusive; a segunda classe será 14,8 até 17,8 (14,8 + 3) e assim por diante.

3. _Construção da tabela_:

Pode-se construir a tabela, usando a função `table()` e dentro desta a função `cut()` e dentro dela a função `seq(limite inferior, limite superior, l = número de classes)`.

```{r}
categImc <- table(cut(mater$imc,
                        rigth = TRUE,
                        include.lowest = TRUE,
                        seq(11.8, 48.7, l = k + 1)))
categImc
```

Preste atenção! Estes comandos que vão gerar a tabela têm o argumento `right = TRUE (padrão)`. Neste caso, ao contrário do comentado anteriormente, onde foi usado `right = FALSE`, os símbolos aparecem como (] (na tabela) e significa que o limite inferior da classe foi excluído (aberto à esquerda) e o superior foi incluído (fechado à direita). Aqui, também foi introduzido o argumento `include.lowest  = TRUE` para incluir o valor mínimo dos dados (11,8), e a representação gráfica fica []. 

Olhando a saída do objeto `nutriCateg`, ela parece pouco esclarecedora e, no caso do IMC, talvez fosse melhor usar outro critério. Como por exemplo o que define o estado nutricional no 1° trimestre de gestação e classifica as gestantes em *baixo peso* (IMC $<$ 18,5 kg/$m^2$), *peso adequado* (18,5 $\le$ IMC $\le$ 24,9 kg/$m^2$), *sobrepeso* (25,0 $\le$ IMC $\le$ 29,9 kg/$m^2$) e *obesidade* (IMC $\ge$ 30 kg/$m^2$). Assim, é recomendado um ganho de peso total adequado de 12,5 kg a 18 kg para as gestantes classificadas como baixo peso; de 11,5 kg a 16,0 kg para as classificadas como peso adequado; de 7,0 a 11,5 kg nas classificadas com sobrepeso; e de 5,0 a 9,0 kg nas obesas [@rasmussen2009weight]. 

```{r echo=TRUE, warning=FALSE, message=FALSE}
mater$estNutri <- cut(mater$imc,
                      breaks = c(11.8, 18.5, 25, 30, 48.7),
                      labels = c("Baixo Peso", "Peso adequado", 
                                 "Sobrepeso", "Obesidade"),
                      include.lowest = TRUE,
                      right = FALSE,
                      ordered_result =TRUE)
```

Isto cria uma nova variável  `estNutri`  (estado nutricional), no conjunto de dados mater, com 4 níveis (baixo Peso, Peso adequado, sobrepeso e Obesidade). Desta forma, pode-se construir uma tabela que melhor define este grupo de mulheres quanto ao estado nutricional.

```{r}
f.abs <- table (mater$estNutri)
f.rel <- round(prop.table(f.abs), 3)
f.perc <- round(f.rel*100, 2)

f.abs <- c (f.abs, sum(f.abs))
f.rel <- c (f.rel, sum (f.rel))
f.perc <- c (f.perc, sum (f.perc))

tab2 <- cbind(f.abs,
              f.rel ,
              f.perc)

tab2 <- as.data.frame(tab2)
row.names(tab2)[5] <-  "Total"
colnames(tab2) <- c("f", "fr", "fp")
tab2
```

Colocando em um formato mais científico, tem-se uma tabela (Tabela \@ref(tab:aripaka)) bem mais elegante sobre o estado nutricional pré-gestacional:

```{r aripaka, echo=TRUE, warning=FALSE, message=FALSE}
knitr::kable(tab2,
             booktabs = TRUE,
             caption = "Estado nutricional pré-gestacional das parturientes, HGCS, 2008.",
             format.args = list(decimal.mark = ",")) %>% 
kableExtra::kable_classic_2(full_width = TRUE,
                            html_font = "Cambria",
                            position = "center") %>% 
kableExtra::row_spec(0, bold = TRUE) %>% 
kableExtra::column_spec(1, width = "3.5cm")  %>% 
kableExtra::column_spec(2:4, width = "2.5cm")  
```

### Tabelas de contingência

As tabelas de contingência, também chamadas tabelas cruzadas, são bastante usadas em estatísticas epidemiológicas para resumir a relação entre duas ou mais variáveis categóricas.   

Uma tabela de contingência é um tipo especial de tabela de distribuição de frequência, onde duas variáveis são mostradas simultaneamente. Por exemplo, um pesquisador pode estar interessado em saber se o hábito de fumar na gestação aumenta o risco de o recém-nascido precisar de cuidados intensivos.  
Existem duas variáveis `fumo` (fumo na gestação) e `utiNeo` (necessidade de cuidados intensivos neonatais) no banco de dados `dadosMater.xlsx`. Cada uma dessas variáveis tem duas alternativas, `sim` e `não`, por isso a tabela de cruzamento é denominada tabela de contingência 2 x 2. No arquivo, estão registradas como variáveis numéricas , 1 e 2, e devem ser transformadas para fatores (1 = sim e 2 = não)^[Poderiam ser transformados em fatores sem trocar os rótulos e manter os números 1 e 2, como se fossem palavras. O autor prefere usar nomes.], usando a função `factor()`.

```{r}
mater$fumo <- factor (mater$fumo, 
                      ordered = TRUE, 
                      levels = c (1,2), 
                      labels = c ("sim", "não"))
mater$utiNeo <- factor (mater$utiNeo, 
                        ordered = TRUE, 
                        levels = c (1,2), 
                        labels = c ("sim", "não"))
```

Basta agora, usar a função `with()` junto com a função `table(variável da linha, variável das colunas)`. Por convenção, costuma-se colocar a variável explicativa ou explanatória nas linhas (`fumo`) e o desfecho nas colunas (`utiNeo`):

```{r}
tabFumo <- with(data = mater, table(fumo, utiNeo))
tabFumo
```

Para ter a soma das margens, usar a função `addmargins (tabela, margin = c (1,2), FUN = sum)` do pacote `stats`, incluído na instalação básica do R. A função adiciona a soma das linhas (1) e das colunas (2) às margens da tabela (`tabFumo`).

```{r }
addmargins (tabFumo, margin = c(1,2), FUN = sum)
```
Observando a tabela de contingência, verifica-se que  a proporção entre as gestantes fumantes  de internação na UTI neonatal foi 71/301 = 0,236 e entre as não fumantes foi de 204/1067 = 0,191. Para verificar se esta diferença ocorreu por acaso ou ela é significativa, há necessidade de se realizar um teste de hipótese, o qui-quadrado, que será visto no Capítulo 16.

## Gráficos  

Para descrever os dados e visualizar o que está acontecendo, recomenda-se utilizar um gráfico adequado. O que é adequado depende principalmente do tipo de dados, bem como das características particulares do que se quer explorar. Além disso, um gráfico em um relatório sempre é um fator de "impacto". Ou seja, pode ter um efeito positivo no leitor ou fazê-lo abandonar a leitura. Finalmente, um gráfico de frequência pode ser utilizado para ilustrar, explicar uma situação complexa onde palavras ou uma tabela podem ser confusos, extensos ou de outro modo insuficiente. Por outro lado, deve-se evitar usar gráficos onde poucas palavras expressam claramente o que se quer mostrar. Aconselha-se que, ao analisar os dados, é importante inspecioná-los como se fossem uma imagem, uma fotografia, ver como eles se parecem, qual o seu aspecto, e só então pensar em interpretar os aspectos vitais da estatística [@field2012graphs].  

O R básico fornece uma grande variedade de funções para visualizar dados, elas de uma maneira relativamente simples permitem a construção de gráficos que facilitam a interpretação tanto de variáveis categórica como contínuas. Para gráficos mais sofisticados existe um pacote denominado `ggplot2` [@wickham2016getting]. Este pacote é uma ferramenta extremamente versátil. É um pouco mais complexo e exige mais tempo para dominá-lo, mas, uma vez que se aprenda o básico sobre ele, oferece uma estrutura extremamente flexível para exibir os dados . Inicialmente, serão usadas as funções do R básico e,posteriormente, será feita uma introdução ao `ggplot2` (seção \@ref(sec-ggplot2)).  

### Gráfico de setores  

Também conhecido como gráfico de *pizza*. Cada segmento (fatia) do gráfico de pizza deve ser proporcional à frequência da categoria que representa. A desvantagem do gráfico de pizza é que ele só pode representar uma variável, portanto, há necessidade de um gráfico separado para cada variável que se deseja representar. Além disso, um gráfico de pizza pode perder clareza se ele é usado para representar mais do que quatro ou cinco categorias. Na maioria das vezes, em um artigo ou relatório não há necessidade de se usar este tipo de gráfico. As tabelas são muito melhores.  Segundo Edward Tufte, professor emérito de estatística, *design* gráfico e economia política na Universidade de Yale, o único gráfico pior do que um gráfico de pizza são vários deles [@tufte2001aesthetics]! Ele é usado mais no mundo dos negócios. Como regra, não use gráfico de pizza!  

Em uma consulta, entre estudantes de Medicina, foi perguntado a sua opinião em relação a este tipo de gráfico. A pergunta feita foi: “O que você sente ao ver um gráfico de pizza em um artigo científico?” As alternativas para a resposta eram quatro (ódio, irritação, indiferença, amor). O resultado do inquérito está na Tabela \@ref(tab:pizza). 

```{r pizza, echo=FALSE, warning=FALSE, message=FALSE}
library (kableExtra)
options(knitr.kable.NA = '')
knitr::kable(data.frame(Sentimento = c("Odeiam", "Não gostam", 
                                       "Indiferentes", "Amam", "Total"),
                        f = c(6, 12, 14, 8, 40),
                        fr = c(0.15, 0.30, 0.35, 0.20, 1.00),
                        fp = c(15, 30, 35, 20, 100),
                        Fp = c(15, 45, 80, 100, NA)),
             caption = "Sentimento dos alunos de Medicina em relação ao gráfico de pizza, UCS, 2012.",
             format.args = list(decimal.mark = ",")) %>% 
kableExtra::kable_classic(full_width = F, html_font = "Cambria") %>% 
kableExtra::column_spec(1, width = "3.5cm") %>% 
kableExtra::column_spec(2:5, width = "1.5cm") %>% 
kableExtra::row_spec(0, bold = TRUE)
```

No R base, pacote `graphics`, existe a função `pie()`para obter um gráfico de setores simples. Esta função usa os seguintes argumentos basicos, consulte a ajuda do R para outras informações:

* *x*       $\longrightarrow$ vetor numérico não negativo  
* *labels*  $\longrightarrow$  caracteres que fornecem nomes para as fatias. Para rótulos vazios ou NA (após coerção para caractere), nenhum rótulo ou linha indicadora é desenhada  
* *radius*  $\longrightarrow$ A pizza é desenhada centralizada em um quadrado cujos lados variam de -1 a +1. Se os caracteres que rotulam as fatias forem longos, pode ser necessário usar um raio menor. O padrão é 0,8.  
* *density* $\longrightarrow$  Densidade das linhas de sombreamento, em linhas por polegada. O padrão é NULL significa que nenhuma linha de sombreamento é desenhada. Valores não positivos de densidade também inibem o desenho de linhas sombreadas 
* *col*     $\longrightarrow$ Vetor de cores a ser usado no preenchimento ou sombreamento das fatias. Se estiver faltando, um conjunto de 6 cores pastel é usado   

Os valores da coluna de frequência absoluta (*f*) da Tabela \@ref(tab:pizza) serão usados como o argumento *x*. Ele informa a área (proporção de cada fatia. Os rótulos das fatias são escritos com a função concatenar `c()`.  

```{r pie, out.width="100%", out.height="100%", fig.align='center', fig.cap="Gráfico de Pizza: Opinião dos estudantes de Medicina.", fig.pos="H"}
pie(x = c(6, 12, 14, 8),
    labels = c("Odeiam", "Não gostam", "Indiferentes", "Amam"))
```

 As cores que aparecem na Figura \@ref(fig:pie) foram escolhidas pelo R, usando o seu padrão. Entretanto, elas podem ser customizadas, especificando-as pelo nome colocado entre parênteses. Por exemplo, `col = "red"` e se for mais de uma cor usar a função concatenar, `col = c(“gray58“, “yellow4”, “cyan”, “tomato”)`.  As cores também podem se denotadas pelo sistemas  RGB  ou hexadecimal. A sigla RGB representa as cores primária em inglês (Red, Green, Blue). O código hexadecimal da cor branca é #FFFFFFF, da gray58 é  #949494,  da yellow4 é #999900, da cyan é #00FFFFe da tomato é #FF6347 (Figura \@ref(fig:pie2)).

```{r pie2, out.width="100%", out.height="100%", fig.align="center", fig.cap="Figura anterior com cores personalizadas.", fig.pos="H"}

pie(x = c(6, 12, 14, 8),
    labels = c("Odeiam", "Não gostam", "Indiferentes", "Amam"),
    col = c("gray58", "yellow4", "cyan", "tomato"))
```

As cores parecem espetaculosas, mas o objetivo foi de criticar os gráficos tipo pista. Se o leitor quiser insistir no seu uso e com um gráfico em 3D (Figura \@ref(fig:pie3d)), pode-se instalar o pacote `plotrix` (@lemon2015package) e carregar a função `pie3D()`. Os argumentos são praticamente os mesmos do gráfico simples. Acrescenta-se `radius = 0.9` que muda o raio da pizza e `explode = 0.1` que determina o afastamento das fatias (0, as mantém juntas). Além disso, como o gráfico exibe rótulos com textos muito grandes, usa-se o argumento `labelcex = 1`. Como qualquer função nova, basta clicar na tecla *Tab*, dentro da mesma, que aparece um menu com as alternativas de argumentos.

```{r pie3d, out.width="100%", out.height="100%", fig.align='center', fig.cap="Gráfico de Pizza: Opinião dos estudantes de Medicina.", fig.pos="H"}
library (plotrix)

pie3D(x = c(6, 12, 14, 8),
    labels = c("Odeiam", "Não gostam", "Indiferentes", "Amam"),
    radius = 0.9,
    explode = 0.1,
    col = c("gray58", "yellow4", "cyan", "tomato"),
    labelcex = 1)
```

### Gráfico de barras

Os gráficos de barra exibem a distribuição (frequências) de uma variável categórica através de barras verticais ou horizontais, ou sobrepostas [@kabacoff2011graphs].   

Assim como o gráfico de setores, o gráfico de barras é utilizado para representar a frequência absoluta ou percentual de diferentes categorias. As barras são proporcionais as frequências. A forma mais simples de solicitar um gráfico de barra no R é digitar a função `barplot()` do pacote básico. Esta função é específica para desenhar gráficos de barras horizontais e verticais e usa os seguintes argumentos:

* *height*  $\longrightarrow$ um vetor  ou matriz de valores que descreve as barras que constituem o gráfico;  
* *width*   $\longrightarrow$ especifica largura das barras, com padrão de 1, opcional;  
* *space*   $\longrightarrow$ a quantidade de espaço (como uma fração da largura média da barra) restante antes de cada barra. Pode ser fornecido como um único número ou um número por barra;  
* *beside*  $\longrightarrow$ argumento lógico para especificar se colunas devem ser mostradas lado a lado;  
* *col*     $\longrightarrow$ cores das barras componentes das barras, por padrão é usado *grey* (cinza);  
* *border*  $\longrightarrow$ cor das bordas das barras;  
* *...*     $\longrightarrow$ outros argumentos. Consulte a ajuda do R.

Para a construção do gráfico de barras simples da Figura \@ref(fig:barra1)), foi utilizada a variável `categIdade`, anteriormente criada, a partir do conjunto de dados `dadosMater.xlsx`.

```{r barra1, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de barra simples.", fig.pos="H"}
barplot(table(mater$categIdade))
```

Observando a Figura \@ref(fig:barra1), verifica-se que não existem rótulos nos eixos *x* e *y* e o eixo *y* tem um tamanho inferior a barra mais alta. Estes e outros problemas podem ser resolvidos modificando-se ou acrescentando outros argumentos na função `barplot()`. Existem vários argumentos e para conhece-los melhorpesquise no Help do RStudio. Em um gráfico de barra simples são suficientes as seguintes modificações que irão resultar na Figura \@ref(fig:barra2): 

* Para corrigir a amplitude do eixo *y*, existe o argumento `ylim = c(lim inf, lim sup)`. Na Tabela \@ref(tab:tisch), observa-se que a frequência máxima é de 992, assim estende-se até 1000, bem próximo da frequência da categoria, acrescentando `ylim = c (0,1000)`, separado por vírgulas de outros argumentos.
* Para os rótulos se utiliza os argumentos `ylab = (“Frequência”)` e xlab = (“Faixa Etária”). Também, pode ser incluído um título no gráfico com o argumento m`ain = “Título”`. Observe que os títulos estão entre aspas.
* Para modificar o tamanho das letras dos eixos *x* e *y*, que estão pouco visíveis, existe o argumento `cex.lab = 1`, que é o padrão. Para aumentar em 30%, por exemplo, usar `cex.lab = 1.3`. Os nomes tem padrão `cex.names = 1,` para modificar pode-se usar 1.3, 1.5, etc. Se nada for modificado, o R imprime o padrão.
* Para a cor das barras, use o argumento `col = (“cor”)`. Escolha a cor entre as 657 opções, ou deixe o padrão cinza (grey). O argumento `col.axis = “cor”` controla a cor dos valores dos eixos.
* Para modificar a borda das barras que por padrão é preta, é possível mudar, usando o argumento `border = “cor”`. Sem borda basta colocar 0 (zero), no lugar da cor.
*	Para colocar as barras na posição horizontal, pode ser utilizado o argumento `horiz = TRUE`. Lembrar de inverter as barras. Ou seja, a variável x passa a ser y e vice-versa.
* O argumento las = 1 faz o o texto do eixo *y* ficar horizontal 
*  A função `box(bty = "L")`, colocada após, e opcional, faz os eixos se encontraren em 0.

```{r barra2, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de barra simples modificado.", fig.pos="H"}
barplot(table(mater$categIdade), 
        ylim = c (0,1000), 
        col= "tomato", 
        border = "black", 
        ylab= "Frequência absoluta", 
        xlab = "Faixa etária", 
        cex.lab = 1.2,
        las = 1)
box(bty = "L")
```

Para que as barras fiquem horizontais como na Figura \@ref(fig:barrah), usa-se o argumento `horiz=TRUE`:

```{r barrah, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico com barras horizontais.", fig.pos="H"}
barplot(table(mater$categIdade), 
        xlim = c (0,1000), 
        col= "tomato", 
        border = "black", 
        ylab= "Faixa Etária", 
        xlab = "Frequência absoluta", 
        cex.lab = 1.2, 
        horiz=TRUE)
box(bty = "L")
```

Além das modificações realizadas, é possível fazer outras para tornar o gráfico mais informativo . Por exemplo, pode-se colocar as frequência de cada barra no topo das mesmas (Figura \@ref(fig:barra3)):

* **1º Passo**: Criar um gráfico de barras , colocando-o em um objeto *x*, que conterá a coordenada X do centro de cada uma das barras. Para verificar isso, basta executar o objeto *x*;
* **2º Passo**: colocar a tabela `table(mater$idadeCateg)` com um objeto *y* da classe matriz;
* **3º Passo**: usar a funçãoo `text()` para colocar os valores.

```{r barra3, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de barra simples com frequências no topo.", fig.pos="H"}
x <- barplot(table(mater$categIdade), 
             ylim = c (0,1000), 
             col= "springgreen", 
             border = "black", 
             ylab = "Frequência absoluta", 
             xlab = "Faixa etária", 
             cex.lab = 1.2,
             las = 1)
box(bty = "L")

y <- as.matrix(table(mater$categIdade))

text (x, y, labels = as.character(y), adj = c(0.5, 2), col = "black")
```

#### Gráfico de barras empilhadas  

Para este tipo de apresentação são utilizados, praticamente, os mesmos argumentos vistos para gerar um gráfico de barra simples. Como existem duas variáveis, há necessidade de avisar ao R como elas devem aparecer. Para isso, entra o argumento `beside = FALSE`, que informa que as barras não estarão uma ao lado da outra e sim empilhadas (Figura \@ref(fig:stacked)). O padrão é as barras ficarem uma ao lado da outra.   

Acrescenta-se uma legenda com a função `legend()` na parte superior esquerda (`topleft`). O argumento `bty = "n"` informa que será removido o quadro ao redor da legenda e `fill = c("dimgrey", "salmon")` são as cores das barras.  

As duas variáveis a serem visualizadas são o *hábito tabagista* entre as puérperas de acordo com a *idade*. No conjunto de dados dadosMater.xlsx, o hábito tabagista está registrado na variável `fumo`, vista quando se estudou tabelas de contingência. Aqui se construirá uma tabela 3 x 2, `tabFumo2`: 

```{r stacked, out.width="90%", out.height="90%", fig.align='center', fig.cap="Gráfico de barras empilhadas.", fig.pos="H"}
tabFumo2 <- table(mater$fumo, mater$categIdade)

barplot(tabFumo2,
        beside = FALSE,
        ylim = c(0, 1000),
        xlab="Faixa Etária", 
        ylab = "Frequência", 
        col = c ("dimgrey", "cadetblue1"),  
        cex.lab = 1, 
        cex.axis = 1, 
        cex.names = 1,
        las = 1)
box(bty = "L")
legend ("topleft",
        legend = c("Fumantes", "Não Fumantes"), 
        fill = c("dimgrey", "cadetblue1"), 
        bty="n", 
        cex = 1)
```

#### Gráfico de barras lado a lado  

É igual a anterior, apenas com o argumento `beside = TRUE` (Figura \@ref(fig:side)).

```{r side, out.width="90%", out.height="90%", fig.align='center', fig.cap="Gráfico de barras lado a lado", fig.pos="H"}
barplot(tabFumo2,
        beside = TRUE,
        ylim = c(0, 1000),
        xlab="Faixa Etária", 
        ylab = "Frequência", 
        col = c ("dimgrey", "cadetblue1"),  
        cex.lab = 1, 
        cex.axis = 1, 
        cex.names = 1,
        las = 1)
box(bty = "L")
legend ("topleft",
        legend = c("Fumantes", "Não Fumantes"), 
        fill = c("dimgrey", "cadetblue1"), 
        bty="n", 
        cex = 1)
```

#### Gráfico de barras para uma variável discreta

A variável `mater$para`, número de filhos anteriores ao atual, é uma variável numérica discreta e, para representá-la, o mais adequado é usar um gráfico de barras simples Figura \@ref(fig:discreta)).

```{r discreta, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de barras para uma variável discreta", fig.pos="H"}
tab_filhos<- table (mater$para) 

barplot (tab_filhos, 
         col = "tomato", 
         xlab="Número de filhos anteriores ao atual", 
         ylab = "Frequência",
         ylim = c(0, 500),
         cex.lab = 1, 
         cex.axis = 1, 
         cex.names = 1,
         las = 1)
box(bty = "L")
```

### Gráfico de barra de erro

O *gráfico de barra de erro* é um tipo de gráfico barra acrescido de uma medida de dispersão: desvio padrão, intervalos de confiança ou erro padrão. As barras de erro dão uma ideia geral de quão precisa é uma medição ou, inversamente, quão longe o valor observado está do valor verdadeiro.  

Continuando a usar o arquivo `dadosMater.xlsx`, será selecionada uma amostra de recém-nascidos a termo, definido pela OMS como o nascido de 37 semanas completas a 42 semanas incompletas (259 a 293 dias). A partir destes dados, será construido um gráfico de barra de erro dos recém-nascidos do sexo masculino e feminino.  

Inicialmente, deve ser instalado e carregado o pacote  `Hmisc` @harrell2022hmisc, necessário para fornecer a função `errbar()` que irá construir o gráfico de de barra de erro.

A seguir, serão filtrados do conjunto de dados em uso, `mater`, os recém-nascidos a termo. O conjunto resultante será atribuído a um objeto denominado `rnt` e , usando o operador pipe %>%  será usada a função `summarise()` e `group_by()` provenientes do pacote `dplyr`, para calcular as medidas resumidoras, de acordo com o sexo. Como a variável `sexo` encontra-se como numérica, será transformada em fator:

```{r}
mater$sexo <- factor(mater$sexo,
                      labels = c('masc', 'fem'))
 
 rnt <- mater %>% 
   filter(ig >= 37 & ig < 42) %>% 
   group_by(sexo) %>% 
   summarise(n = n(),
             media = mean(pesoRN, na.rm = T),
             dp = sd(pesoRN, na.rm = T),
             l_inf = media - 1.96*dp,
             l_sup = media + 1.96*dp)

 rnt
```

O próximo passo é criar um objeto, denominado `barras`, que irá receber as médias dos pesos dos recém-nascidos masculinos e femininos, que representam a altura das barras. Este objeta servirá de base para a construção de um gráfico de barras que será recebido por outro objeto, `bp`.
Finalmente, coloca-se os limites inferiores e superiores para cada sexo, usando os valores calculados pela função summarise() que junto com o objeto bp constituem-se de argumentos da função `errbar()` (Figura \@ref(fig:errorbar)). Veja maiores detalhes na ajuda do R (`?errbar`).

```{r errorbar, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de barras de erro", fig.pos="H"}
barras <- c(rnt$media[1], rnt$media[2])

 bp <- barplot(barras,
               ylim=c(0,4200), 
               ylab = "Peso do Recém-nascido (g)",
               cex.lab = 1.2,
               cex.axis = 0.8,
               cex.names = 1,
               space = c(0,0.5),
               names.arg=c("Meninos", "Meninas"), 
               col = c("lightblue", " pink2"),
               las = 1)
 box(bty = "L")

 lim_inf <- c(rnt$l_inf[1], rnt$l_inf[2])
 lim_sup <- c(rnt$l_sup[1], rnt$l_sup[2])

 errbar(bp, barras, lim_inf, lim_sup, add = TRUE, xlab = NULL)
```

### Histograma  

O *histograma* é uma ferramenta gráfica que fornece informações sobre o formato da distribuição e dispersão dos dados, permitindo verificar se existe ou não simetria. É usado para dados contínuos.    

No histograma, as frequências observadas são representadas por intervalos de classes de ocorrência que estão no eixo *x* e a altura das barras, representando a frequência de cada intervalo, no eixo *y*. A área de cada barra é proporcional à porcentagem de observações de cada intervalo.   

O R base possui uma função, denominada de `hist()` que constroi o histograma e possui vários argumentos:  

* *x*  $\longrightarrow$ um vetor numérico usado na construção do histograma  
* *breaks*   $\longrightarrow$ especifica o número de barras
* *freq*   $\longrightarrow$ lógico; se `TRUE` (padrão), o histograma é uma representação de frequências; se `FALSE`, densidades de probabilidade, densidade de componentes, são plotados
* *col*  $\longrightarrow$ cor a ser usada para preencher as barras. O padrão de NULL produz barras não preenchidas 
* *border*  $\longrightarrow$ cor da borda ao redor das barras. O padrão é usar a cor de primeiro plano padrão
* *main, xlab, ylab* $\longrightarrow$ rótulo do título, do eixo *x* e do eixo *y*. Para remover o rótulousar `NULL.`
* *xlim, ylim*  $\longrightarrow$ limites do eixo *x* e do eixo *y*.  

#### Histograma Simples  

Será usada a variável altura, proveniente da arquivo mater (veja início da seção), para a construção do histograma, executando:.

```{r histb, out.width="80%", out.height="80%", fig.align='center', fig.cap="Histograma básico", fig.pos="H"}
hist(mater$altura)
```

No histograma da Figura \@ref(fig:histb), observam-se alguns problemas que devem ser melhorados para tornar a sua aparência mais elegante.

* O rótulo dos eixo *x* está com o nome da variável e do eixo *y* está em inglês;
* O título do histograma está em inglês e repete o eixo *x*. Pode ser removido. 
* O eixo *y* tem um limite superior menor do que a barra mais alta;
* O gráfico está na cor cinza, que conforme o interesse pode ser modificada;
* O número de barras pode ser modificado com o argumento `breaks`. Existe uma função no R que permite calcular o número de intervalos, usando a *regra de Sturges* (`nclass.Sturges()`). Entretanto, na maioria das vezes, é o objetivo do estudo quem determina o número de barras e, também, porque nem sempre o R obedece ao argumento.  

É importante saber o limite inferior e superior da variável, para construir o eixo *x*. Pode-se fazer isso, com as funções `min()` e `max()`:

```{r}
min(mater$altura, na.rm = TRUE)
max(mater$altura, na.rm = TRUE)
```

O número de classes é igual a:

```{r}
nclass.Sturges(mater$altura)
```

Acrescentado argumentos, modifica-se o aspecto do histograma (Figura \@ref(fig:histmod)):

```{r histmod, out.width="80%", out.height="80%", fig.align='center', fig.cap="Histograma modificado", fig.pos="H"}
hist(mater$altura,
     breaks = 12,
     ylim = c (0, 450),
     xlim = c (1.4, 1.9),
     main= NULL, 
     ylab = "Frequência", 
     xlab = "Altura da gestante (metros)",
     col = "tomato",
     las = 1)
box(bty = "L")
```

Observe que o formato do histograma é igual ao anterior, mudando a cor das barras, o limite do eixo *y* e os rótulos dos eixos. O R não modificou o número de barras. Ou seja, não obedeceu à modificação do argumento breaks = 12. Ele escolheu o que achou mais adequado!

#### Histograma com curva normal sobreposta

Eventualmente, para melhor comparar a distribuição dos dados, usamos uma curva normal sobreposta que servirá de indicador (Figura \@ref(fig:histnormal)). A distribuição normal será discutida mais adiante (Capítulo 7).

1) Construir um histograma de densidade, que é a proporção de todas as observações que se enquadram dentro do intervalo. Na função `hist()`, modificar o argumento  para `freq = FALSE`.

2) Adicionar uma curva normal ao histograma, usando a função `curve()`. Calcular antes a média e o desvio padrão da variável `mater$altura`.

```{r histnormal, out.width="80%", out.height="80%", fig.align='center', fig.cap="Histograma com curva normal sobreposta", fig.pos="H"}
mu <- mean(mater$altura, na.rm =TRUE)
dp <- sd(mater$altura, na.rm = TRUE)

hist(mater$altura,
     ylim = c (0, 6),
     xlim = c (1.4, 1.9),
     main= NULL, 
     ylab = "Densidade", 
     xlab = "Altura da gestante (metros)",
     col ="steelblue",
     freq = FALSE,            
     border = "white")
box (bty = "L")

curve (dnorm (x, 
              mean=mu, 
              sd=dp), 
       col="red", 
       lty=1,
       lwd=2,
       add=TRUE)
```

#### Componentes do Histograma

Para verificar a lista de componentes de um histograma , há necessidade de colocar o histograma da Figura \@ref(fig:histh) em um objeto, no exemplo, denominado de h:

```{r histh, out.width="80%", out.height="80%", fig.align='center', fig.cap="Histograma da altura da gestante", fig.pos="H"}
h <- hist(mater$altura,
          breaks = 8,
          ylim = c (0, 450),
          xlim = c (1.4, 1.9),
          main= NULL, 
          ylab = "Frequência", 
          xlab = "Altura da gestante (metros)",
          col ="tomato",
          freq = TRUE,           
          border = "white")
      box (bty = "L")
h
```

Uma das utilidades dos componentes, é construir um histograma com os valores correspondentes as barras sobrepostos ao gráfico (Figura \@ref(fig:histfreq)).

```{r histfreq, out.width="80%", out.height="80%", fig.align='center', fig.cap="Histograma com frequência sobreposta", fig.pos="H"}
hist(mater$altura,
     breaks = 8,
     ylim = c (0, 450),
     xlim = c (1.4, 1.9),
     main= NULL, 
     ylab = "Frequência", 
     xlab = "Altura da gestante (metros)",
     col = "salmon")
box (bty = "L")

text (h$mids, h$counts, labels = h$counts, adj= c(0.5, -0.5))
```

Note que as informações deste gráfico são as mesmas de uma tabela de frequência construída com os mesmos dados. Maneiras diferentes de informar uma distribuição de frequência (veja seção sobre tabelas de frequência).

### Boxplot  {#sec-bxp}

O *boxplot* descreve a distribuição de uma variável contínua exibindo o resumo de cinco números: mínimo, 1º quartil (percentil 25), mediana (percentil 50), 3ª quartil (percentil 75) e máximo (Figura \@ref(fig:boxplot)).

```{r boxplot, echo = FALSE,out.height= '70%', out.width = '70%', fig.align = 'center', fig.cap="Boxplot", fig.pos="H"}
 knitr::include_graphics("https://i.imgur.com/Dh2UszX.png")
```

#### Boxplot a partir de um vetor

Para construir um boxplot, serão usados os mesmos dados dos recém-nascidos a termo, filtrados do conjunto de dados `dadosMater.xlsx`, como realizado na seção da construção de um gráfico de barra de erro. Os dados  obtidos, novamente serão atribuídos a um objeto de nome `rnt`. A variável usada para construir o boxplot será `rnt$pesoRN`.

```{r}
rnt <- read_excel("Arquivos/dadosMater.xlsx") %>% 
  select(idadeMae, altura, peso, anosEst, fumo, 
         para, ig, sexo, pesoRN, compRN, utiNeo) %>% 
  filter(ig >= 37 & ig < 42)
```

O R possui uma função no pacote básico denominada `boxplot()` que será usada para construir o gráfico da Figura \@ref(fig:bxp). A função solicita vários argumentos que podem alterar a sua aparência e devem ser utilizados de acordo com necessidade:  

*	*formula* $\longrightarrow$ este parâmetro é definido como um vetor ou uma fórmula (y ~ grupo);
*	*data* $\longrightarrow$este parâmetro define o conjunto de dados;
*	*notch* $\longrightarrow$ parâmetro lógico. Se TRUE um entalhe será desenhado em cada lado da caixa, representando o intervalo de confiança para a mediana. Se os entalhes de dois boxplots não se sobrepuserem, indica uma “forte evidência” de que as duas medianas diferem;
*	*varwidth* $\longrightarrow$ parâmetro lógico. Se for TRUE, as caixas serão desenhadas com larguras proporcionais às raízes quadradas do número de observações nos grupos;
*	*border*  $\longrightarrow$um vetor opcional de cores para os contornos dos boxplots:
*	*main* $\longrightarrow$ este parâmetro é o título do gráfico;
*	*xlab*, *ylab* ⟶ rótulos dos eixos x e y ;
*	*cex* $\longrightarrow$ver https://www.statology.org/r-plot-cex/;
*	*las* $\longrightarrow$altera orientação do rótulos do eixo. Valores aceitos 0 (paralelo ao eixo), 1 (horizontal), 2 (perpendicular) e 3 (vertical);
*	*names* $\longrightarrow$ Este parâmetro são os rótulos dos grupos que serão mostrados em cada boxplot;
*	... $\longrightarrow$ Outros parâmetros (ver ajuda do R, digitando ?boxplot no Console)

```{r bxp, out.width="80%", out.height="80%", fig.align='center', fig.cap="Boxplot simples", fig.pos="H"}
boxplot (rnt$pesoRN)
```

Esse boxplot pode ser modificado (Figura \@ref(fig:bxpmod)), alterando alguns argumentos como colocação de um título no gráfico, e rótulos nos eixos e mudança na cor. Os argumento `cex.lab`, `cex.axis` e `cex.names` estabelecem o tamanho fontes. Por exemplo, para aumentar em 20%, usamos 1.2.

```{r bxpmod, out.width="80%", out.height="80%", fig.align='center', fig.cap="Boxplot modificado", fig.pos="H"}
boxplot (rnt$pesoRN, 
         col = "lightblue2", 
         main = "RN a termo", 
         ylab = "Peso do Recém-nascido (g)",
         border = "black",
         cex.lab = 1.2, 
         cex.axis = 1, 
         cex.names = 1,
         las = 1)
```

#### Interpretação do boxplot

O boxplot nos fornece uma análise visual da posição, dispersão, simetria, caudas e valores discrepantes (*outliers*) do conjunto de dados (Figura \@ref(fig:boxplot)).  

*	**Posição** – Em relação à posição dos dados, observa-se a linha central do retângulo (a mediana ou segundo quartil).
*	**Dispersão** – A dispersão dos dados pode ser representada pelo intervalo interquartil (IIQ), tamanho da caixa, que é a diferença entre o terceiro quartil (3ºQ) e o primeiro quartil (1ºQ), ou ainda pela amplitude que é calculada da seguinte maneira: valor máximo – valor mínimo. Embora a amplitude seja de fácil entendimento, o intervalo interquartil é uma estatística mais robusta para medir variabilidade uma vez que não sofre influência de *outliers*.
*	**Simetria** – Um conjunto de dados que tem uma distribuição simétrica, terá a linha da mediana no centro do retângulo. Quando a linha da mediana está próxima ao primeiro quartil, os dados são assimétricos positivos e quando a posição da linha da mediana é próxima ao terceiro quartil, os dados são assimétricos negativos. Vale lembrar que a mediana é a medida de tendência central mais indicada quando os dados possuem distribuição assimétrica, uma vez que a média aritmética é influenciada pelos valores extremos.
*	**Caudas** – As linhas que vão do retângulo até aos outliers podem fornecer o comprimento das caudas da distribuição.
*	**Valores atípicos** (*Outliers*) – Os outliers indicam possíveis valores discrepantes. No boxplot, as observações são consideradas *outliers* quando estão abaixo ou acima dos limites superior e inferior. O limite de detecção de outliers é construído utilizando o intervalo interquartil, dado pela distância entre o primeiro e o terceiro quartil. Sendo assim, os limites inferior e superior de detecção de outlier são dados por:
 o	*Limite Inferior*: 1ºQ – (1,5 * IIQ);
 o	*Limite Superior*: 3ºQ + (1,5 * IIQ). Tanto o limite superior como o inferior são representados por (º).
 o	Valores extremos: Valores que estão acima ou abaixo de 3 vezes o IIQ são considerados extremos, representados por (*).

#### Adicionando pontos ao boxplot

Quando se observa um boxplot, verifica-se que os mesmos ocultam a distribuição subjacente dos dados. Para resolver este “problema”, pode-se adicionar pontos ao gráfico, usando a função `stripchart()`. Esta função permite criar um gráfico de dispersão unidimensional sobreposto ao boxplot  (Figura \@ref(fig:boxstrip)). Os comandos para esta ação são:

```{r boxstrip, out.width="80%", out.height="80%", fig.align='center', fig.cap="Boxplot com pontos de dispersão", fig.pos="H"}
boxplot (rnt$pesoRN, 
          col = "lightblue2", 
          ylab = "Peso do Recém-nascido (g)", 
          border = "black",
          cex.lab = 1.2, 
          cex.axis = 1, 
          cex.names = 1,
          las = 1)

 stripchart(x= rnt$pesoRN, 
            method = "jitter", 
            col = "tomato",
            cex = 0.5,
            pch = 16,
            vertical = TRUE, 
            add = TRUE)
```

Neste exemplo, há uma grande sobreposição de pontos, pois a amostra é muito grande (n = 1085). Isto dificulta um pouco a visualização, mas ajuda a ver como a dispersão se comporta. 
Você também pode personalizar o símbolo (pontos) para criar o gráfico, a largura da linha e sua cor com os argumentos `pch`, `lwd` e `col`, respectivamente. Alguns símbolos, como `pch = 21` a `25` permitem que você modifique a cor de fundo do símbolo com o argumento `bg`. O argumento `vertical = TRUE`, coloca os pontos na vertical sobreposto ao boxplot, quando o argumento `add = TRUE`. O argumento `cex = 0.5` é o tamanho dos pontos e `method = "jitter"`, espalha os pontos para diminuir a sobreposição entre eles.

#### Boxplot com intervalos de confiança para a mediana

É possível representar os intervalos de confiança de 95% para a mediana em um boxplot (Figura \@ref(fig:boxnotch)), definindo o argumento `notch` como `TRUE`.

```{r boxnotch, out.width="80%", out.height="80%", fig.align='center', fig.cap="Boxplot modificado", fig.pos="H"}
boxplot (rnt$pesoRN, 
          col = "lightblue2", 
          ylab = "Peso do Recém-nascido (g)", 
          border = "black",
          cex.lab = 1.2, 
          cex.axis = 1, 
          cex.names = 1,
          las = 1,
          notch = TRUE)
```

#### Estatísticas do boxplot 

A função `boxplot.stats()` do pacote `grDevices` fornece as estatísticas do boxplot, facilitando a interpretação do mesmo, de modo semelhante ao visto para o histograma.

```{r}
boxplot.stats (rnt$pesoRN)
```

__Interpretação__  
* $stats = é o resumo dos 5 números: mínimo, percentil 25, mediana, percentil 75 e máximo;  
* $n = nº de obs;   
* $conf = limite inf/sup do entalhe se houver;  
* $out = são os *outliers*.  

#### Múltiplos boxplots

Os boxplots são muito usados na comparação de grupos. A necessidade mais comum é ordenar as categorias de acordo com o aumento da mediana, mas isto é opcional. Permite identificar rapidamente qual grupo tem o maior valor e como as categorias são classificadas (Figura \@ref(fig:bxpm)).  
Será realizada uma comparação visual, usando boxplots, dos pesos dos recém-nascidos por sexo. As variáveis são `rnt$pesoRN` e `rnt$sexo`. Esta última está codificada como numérica 1 e 2, portanto há necessidade de ser transformada em fator:

```{r}
rnt$sexo <- factor(rnt$sexo,
                   levels = c(1, 2),
                   labels = c("masc", "fem"))
```


```{r bxpm, out.width="80%", out.height="80%", fig.align='center', fig.cap="Múltiplos boxplots", fig.pos="H"}
boxplot (rnt$pesoRN ~ rnt$sexo, 
         col = c("lightblue2", "pink"), 
         ylab = "Peso do Recém-nascido (g)", 
         xlab = "Sexo",
         ylim = c(1000, 5000),
         border = "black",
         cex.lab = 1, 
         cex.axis = 1, 
         cex.names = 1,
         las = 1)
```

Observe que foi utilizado o argumento `rnt$pesoRN ~ rnt$sexo` (*y ~ grupo*) para obter os dois boxplots. Existe uma pequena diferença entre eles, as caixas são quase coincidentes.. Foi suprimido o argumento (`xlab = sexo`) relativo ao rótulo do eixo *x*, pois seria redundante.  

Pode-se fazer um entalhe (*notch*) que podem ser interpretados como um intervalo de confiança em torno dos valores medianos (Figura \@ref(fig:bxpnotch)). É calculado pela fórmula :$mediana \pm 1.57\times IIQ/\sqrt{n}$. No nosso exemplo, observe que o entalhe nos meninos está um pouco acima do das meninas..

```{r bxpnotch, out.width="80%", out.height="80%", fig.align='center', fig.cap="Boxplots com entalhes", fig.pos="H"}
boxplot (rnt$pesoRN ~ rnt$sexo, 
         col = c("lightblue2", "pink"), 
         ylab = "Peso do Recém-nascido (g)", 
         xlab = "Sexo",
         ylim = c(1000, 5000),
         border = "black",
         cex.lab = 1, 
         cex.axis = 1, 
         cex.names = 1,
         las = 1,
         notch = TRUE)
```

#### Boxplots horizontais

Para criar um boxplot horizontal (Figura \@ref(fig:bxph)), usamos o argumento `horizontal = TRUE` e invertemos os rotulos dos eixos *x* e *y*.

```{r bxph, out.width="80%", out.height="80%", fig.align='center', fig.cap="Boxplots horizontais", fig.pos="H"}
boxplot (rnt$pesoRN ~ rnt$sexo, 
         col = c("lightblue2", "pink2"), 
         xlab = "Peso do Recém-nascido (g)", 
         ylab = NULL,
         horizontal = TRUE,
         border = "black",
         cex.lab = 1.2, 
         cex.axis = 1, 
         cex.names = 1,
         las = 1)
```

### Gráfico de Dispersão  

Um gráfico de dispersão (*Scatterplot*) exibe a relação entre duas variáveis numéricas (Figura \@ref(fig:scatter)). Cada ponto representa uma observação. Suas posições nos eixos *x* (horizontal) e *y* (vertical) representam os valores das duas variáveis.  

O R Base é uma boa opção para construir um gráfico de dispersão, usando a função `plot()`. Ambas as variáveis numéricas do banco de dados devem ser especificadas nos argumentos *x* e *y*.  

A função `plot()` é uma função genérica que pode ser facilmente editada com múltiplos argumentos envolvendo os eixos e caracteres plotados da mesma maneira que foi feita com os gráficos anteriores. Aqui, novamente, serão usados os dados incluídos no conjunto de dados `rnt`: 

```{r scatter, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de dispersão", fig.pos="H"}
plot (x = rnt$compRN,
      y = rnt$pesoRN,
      ylab = "Peso de Recém-nascido (g)",
      xlab = "Comprimento do Recém-nascido (cm)",
      cex.axis = 0.8,
      las = 1)
```

Este mesmo gráfico pode ser obtido, usando uma fórmula `y~x` e acrescentando o argumento `bty = "L"` (Figura \@ref(fig:scatter1)). Este argumento permite personalizar a caixa ao redor do gráfico. 

* *o*: caixa completa (parâmetro padrão),
* *n*: sem caixa
* *7*: superior + direita
* *L*: inferior + esquerda
* *C*: superior + esquerda + inferior
* *U*: esquerda + inferior + direita

```{r scatter1, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de dispersão", fig.pos="H"}
plot (pesoRN ~ compRN,
      data = rnt,
      ylab = "Peso de Recém-nascido (g)",
      xlab = "Comprimento do Recém-nascido (cm)",
      cex.axis = 0.8,
      las = 1,
      bty = "L")
```

Como em qualquer outro gráfico, este também pode ser melhorado em seu aspecto, tornando os pontos sólidos e coloridos. O argumento `pch` estabelece o tipo de pontos (Figura \@ref(fig:pch)).  

```{r pch, echo = FALSE, out.width = '65%', fig.align = 'center', fig.cap="Símbolo dos formatos", fig.pos="H"}
 knitr::include_graphics("https://i.imgur.com/8VWZSGk.png")
```

Na Figura \@ref(fig:scatter), como os pontos estão aglomerados, devido a quantidade, é possível tentar espalhá-los, usando a função `jitter()` na variável `compRN` (Figura \@ref(fig:jitter)). O argumento 10 é variável e significa o grau de espalhamento:

```{r jitter, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de dispersão com *jitter*", fig.pos="H"}
plot (jitter(rnt$compRN,10),
      rnt$pesoRN,
      col = "steelblue",
      ylab = "Peso de Recém-nascido (g)",
      xlab = "Comprimento do Recém-nascido (cm)",
      las = 1,
      bty = "L",
      pch = 16,
      cex = 1,
      cex.lab = 1.1,
      cex.axis = 0.8)
```

#### Mapeamento dos pontos de acordo com uma variável categórica

Inicialmente, será criado um vetor para representar as cores, de acordo com o sexo (meninos = azul; meninas = vermelho). Usa-se a função `unclass()` para discriminar os sexos (Figura \@ref(fig:map)). Acrescenta-se uma legenda para ilustrar a separação.

```{r map, out.width="80%", out.height="80%", fig.align='center', fig.cap="Mapeamento dos pontos de acordo com uma variável categórica", fig.pos="H"}
cores <- c("dodgerblue3", "tomato")

plot(x = jitter(rnt$compRN, 10), 
  y = rnt$pesoRN,
  bg = cores[unclass(rnt$sexo)],
  ylab = "Peso de Recém-nascido (g)",
  xlab = "Comprimento do Recém-nascido (cm)",
  las = 1,
  bty = "L",
  cex = 1.5,
  pch=21,
  cex.lab = 1,
  cex.axis = 0.8)

legend (legend = c("Meninos", "Meninas"), 
        fill = cores, 
        bty="n", 
        cex = 1,
        "topleft")
```

#### Adição da reta de ajuste

Uma linha reta de ajuste dos dados (Figura \@ref(fig:reta)) pode ser acrescentada usando a função `abline ()`, associada a função `lm ()`. Um modelo típico lm (*linear model*) tem o formato *resposta (*y*) ~ preditor (*x*)*. Mais detalhes sobre o modelo de ajuste linear na regressão linear (veja capítulo 15).


```{r reta, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de dispersão com reta de ajuste", fig.pos="H"}
# Construção do gráfico de dispersão
plot (jitter(rnt$compRN,10),
      rnt$pesoRN,
      col = "gray40",
      bg = "darkturquoise",
      ylab = "Peso de Recém-nascido (g)",
      xlab = "Comprimento do Recém-nascido (cm)",
      las = 1,
      bty = "L",
      pch = 21,
      cex = 1.3,
      cex.lab = 1,
      cex.axis = 0.8)

# Criação do modelo de ajuste
modelo <- lm (rnt$pesoRN ~ rnt$compRN)

# Adição da reta, usando o modelo
abline (modelo, 
        col="red", 
        lwd=2, 
        lty = 2)
```

Ao executar o modelo, se obtém os parâmetros para a construção da equação da regressão linear:

```{r}
summary(modelo)
```

A equação de predição da regressão linear permite que ao conhecer o valor do comprimento é possível prever o peso do recem-nascido:

$$
\hat{y} = b_{0}+ b_{1}\times x
$$

Desta forma, substituindo pelos valores contidos nas estimativas da tabela dos coeficientes do sumário do modelo, um bebê com 50 cm terá um peso de aproximadamente:

$$
\hat{y} = -3416.45 + 137.67\times 50 = 3467.05
$$

## Introdução ao `ggplot2`  {#sec-ggplot2}

O R tem vários sistemas para fazer gráficos e, na ,maioria das vezes, eles são suficientes. Entretanto, o surgimento do `ggplot2` @wickham2016ggplot2 trouxe a possibilidade de serem construídos gráficos mais elegantes e versáteis. Além disso, torna o processo mais rápido,  baseado uma sofisticada gramática [@wickham2010layered].   

O gráfico é construído, usando função `ggplot()`, a partir de alguns elementos básicos ^[O número de elementos pode variar dependendo de como você os agrupa e da pergunta a ser respondida.]:

* *Dados* $\longrightarrow$ os dados brutos que você deseja representar graficamente.
* *Geometria* (*geoms*) $\longrightarrow$ As formas geométricas que irão representar os dados.
* *Estética* (*aes*) $\longrightarrow$ Estética dos objetos geométricos e estatísticos, como posição, cor, tamanho, forma e transparência
* *Escala* (*scales*) $\longrightarrow$ Mapas entre os dados e as dimensões estéticas, como intervalo de dados para plotar largura ou valores de fator para cores.
* *Transformações estatísticas* (*stats*) $\longrightarrow$ resumos estatísticos dos dados, como quantis, curvas ajustadas e somas.
* *Sistemas de coordenadas* (*coordinates Systems*) $\longrightarrow$ A transformação usada para mapear coordenadas de dados no plano do retângulo de dados.
* *Facetas* (*faceting*) $\longrightarrow$ A organização dos dados em uma grade de gráficos.
* *Temas visuais* (*themes*) $\longrightarrow$ Os padrões visuais gerais de um gráfico, como plano de fundo, grades, eixos, tipo de letra padrão, tamanhos e cores.

### Dados usados nesta seção

Serão usados os mesmos dados do conjunto `rnt`, acrescidos da variável `categIdade` (idade categorizada) e da variável categEscola (anos de estudo completos categorizados). 

```{r}
 rnt$categIdade <- cut(rnt$idadeMae,
                       breaks = c(13, 20, 36, 46),
                       labels = c("<20a", "20-35a", ">35a"),
                       include.lowest = TRUE,
                       right = FALSE,
                       ordered_result =TRUE)


 rnt$categEscola <- cut (rnt$anosEst,
                         breaks= c (0,10,13,18),
                         right = FALSE,
                         labels = c("Fundamental",
                                     "Médio",
                                     "Superior"),
                         include.lowest = TRUE,
                         ordered_result =TRUE) 
```

A variável `rnt$fumo` será transformada em fator::

```{r}
rnt$fumo <- factor (rnt$fumo,
                    levels = c(1, 2),
                    labels = c("sim", "não"))
```

### Função ggplot()

A sintaxe do `ggplot2` é diferente do R básico. De acordo com os elementos básicos, um `ggplot` padrão precisa de três informações que devem ser especificadas: os *dados*, a *estética* e a *geometria*. Essas são as camadas principais.  
Será criado um `ggplot` padrão (Figura \@ref(fig:padrao)) que será atribuído a um objeto `g`, usando `data = dados` e a estética (`aes`), no eixo *x*, a variável `compRN` e, no eixo *y*, a variável `pesoRN`.

```{r padrao, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico ggplot padrão", fig.pos="H"}
g <- ggplot (data = rnt, aes (x = compRN, y = pesoRN))
g
```

A este gráfico básico "vazio" adiciona-se uma camada que especifique o tipo de gemometria desejada (Figura \@ref(fig:layer1)). A geometria `geom_point()` retorna um gráfico de dispersão.
  
```{r layer1, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dipersão", fig.pos="H"}
g + geom_point()
```

A estética (`aes`) pode ser definida tanto na camada `ggplot` como na `geom`. Especificando no `ggplot`, esta `aes` será usada em todos os outros geoms que aoarecerem. Usando no `geom`, servirá apenas para ele. No exemplo. é indiferente o local da `aes`, o resultado será o mesmo, pois existe apenas um `geom`.

### Tipos de geoms

Encontra-se uma grande possibilidade de geometrias, de acordo com o tipo de gráfico que será plotado. Elas podem ser visualizadas [**aqui**](https://ggplot2.tidyverse.org/reference/).

#### Histograma
    
O `geom_histogram()` é a geometria para a construção de um histograma. Aqui, há necessidade apenas do eixo *x*, pois existe uma única variável (`pesoRN`). A execução do comando retorna a distribuição dessa variável (Figura \@ref(fig:gghist)):

```{r gghist, message=FALSE, out.width="80%", out.height="80%", fig.align='center', fig.cap="Histograma no 'ggplot2'", fig.pos="H"}
ggplot(data = rnt) +
  geom_histogram(aes(x = pesoRN))
```

#### Gráfico de barras 

A função `geom_bar()`permite delinear um gráfico de barras (Figura \@ref(fig:ggbar)) com a variável `categIdade`:

```{r ggbar, message=FALSE, warning=FALSE, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de barras no 'ggplot2'", fig.pos="H"}
ggplot(data = rnt) +
  geom_bar(aes(x = categIdade, y = after_stat(count/sum(count))))
```

A função `after_stat()` colocada no argumento *y* é usada para determinar o tipo de estatística que irá aparecer no eixo *y*, quando ela não está disponível nos dados. No exemplo, foi usada a proporção que cada categoria representa na variável `categIdade` (`count/sum(count`). Dessa forma, as parturientes acima de 35 anos correspondem a uma proporção de aproximadamente 0,10 (ou 10%).

#### Boxplot

Com o `geom_boxplot()`, serão criados boxplots (Figura \@ref(fig:ggbxp)) comparando os pesos dos neonatos por sexo..

```{r ggbxp, out.width="80%", out.height="80%", fig.align='center', fig.cap="Boxplot no 'ggplot2'", fig.pos="H"}
ggplot(data = rnt) +
  geom_boxplot(aes(x = sexo, y = pesoRN))
```

#### Gráfico de linhas  

Os dados, para produzir o gráfico de linha com a função `geom_line()`, podem ser obtidos [**aqui**](https://github.com/petronioliveira/Arquivos/blob/main/dadosObitos.xlsx), acessar e baixar para o seu diretório de trabalho o arquivo `dadosObitos.xlsx`. Este conjunto de dados é constituído pelos óbitos por COVID-19 no Rio Grande do Sul entre 2020 e 2022.  

Atribua os dados ao objeto `obitos`, a partir do diretório de trabalho.

```{r}
obitos <- read_excel("Arquivos/dadosObitos.xlsx")
str(obitos)
```

Para a construção do gráfico de linha (Figura \@ref(fig:ggline)), use o seguinte comando:

```{r ggline, out.width="80%", out.height="80%", fig.align='center', fig.cap="Gráfico de linha no 'ggplot2'", fig.pos="H"}
ggplot(data = obitos) +
  geom_line(aes(x = data, y = obitos))
```

### Modificação dos argumentos do  geoms

É possível mofificar alguns argumentos no `geom`. Cada tipo de `geom` possibilita alterações específicas.

Inicialmente, serão realizadas modificações no gráfico de dispersão, construído acima com a `geom_point`, modificando a cor, de acordo com o sexo do recém-nascido (Figura \@ref(fig:point)) com o argumento `color=`:

Quando o argumento cor for colocado dentro da `aes`, ele será definido por uma variável, no caso `sexo`. Desta forma, cada um dos sexos serão representados por pontos coloridos diferentes. A escolha da cor foi automática pelo `ggplot2`, entregando duas cores conforme o padrão da sua paleta. Quando o argumento é colocado fora da estética da geom, há necessidade de escolher a cor para os pontos.

```{r point, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dispersão modificado com cores de acordo com o sexo", fig.pos="H"}
ggplot(data = rnt) +
  geom_point(aes(x = compRN, y = pesoRN, 
                 color = sexo))
```

Para modificar o tamanho dos pontos, está disponível o argumento `size =`, colocado na estética do `geom_point()`. O tamanho padrão é 1.5, mas você pode diminuir ou aumentar esse valor para diminuir ou aumentar os pontos (Figura \@ref(fig:point2)).

```{r point2, warning =TRUE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dispersão com cores e tamanhos diferentes dos pontos, de acordo com o sexo", fig.pos="H"}
ggplot(data = rnt) +
  geom_point(aes(x = compRN, y = pesoRN, 
                 color = sexo,
                 size = 1))
```

Além disso, pode-se modificar o formato dos pontos com o argumento `shape =`.  O formato (`shape`) pode ser colocado fora estética e aqui se encontram vários formatos que podem ser usados no `ggplot2`. É possível observar os diferentes formatos (Figura \@ref(fig:pch)) ou usando a função `show_point_shapes()`, encontrada no pacote `ggpubr`.

```{r}
ggpubr::show_point_shapes()
```

### Resumo de dados usando o geom

Inicialmente, serão usados os argumentos `stat = "summary"` e `fun = "mean"` dentro da `geom_point()`. Concomitante, será feito uso do argumento `show.legend = FALSE` para evitar  o aparecimento da legenda, indicando o sexo, pois o eixo *x* já mostra. Pode-se chegar ao mesmo resultado, usando a função `stat_summary()` para acrescentar estatísticas de resumo ^[Consulte https://plotly.com/ggplot2/layers/Stats/stat_summary/]. A execução dos comandos resulta na Figura \@ref(fig:statsummary).

```{r statsummary, warning =FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico resumo, mostrando as médias por sexo", fig.pos="H"}
ggplot(data = rnt, aes(x = sexo, y = pesoRN, color = sexo)) +
   geom_point(stat = "summary",
              fun = "mean",
              size = 3,
              show.legend = FALSE)
```

#### Incluindo barras de erro

Acrescenta-se uma camada `geom_errorbar()`, com os argumentos `stat= summary` e `fun.data = "mean_se"`. Este último argumento fornece a média e o erro padrão e o `width = 0.1`, o tamanho da barra horizontal, gerando o gráfico da Figura \@ref(fig:errsummary):

```{r errsummary, warning =FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barra de erro no ggplot2", fig.pos="H"}
ggplot(data = rnt, 
       aes(x = sexo, 
           y = pesoRN, 
           color = sexo)) +
  geom_point(stat = "summary",
             fun = "mean",
             size = 3,
             show.legend = FALSE) +
  geom_errorbar(stat = "summary", 
                fun.data = "mean_se",
                width = 0.1,
                show.legend = FALSE)
```

Usando o pacote `ggpubr` consegue-se produzir um gráfico (Figura \@ref(fig:errorplot)) semelhante ao da Figura \@ref(fig:errsummary) que usa (média ± erro padrão), mas com o intervalo de confiança  (média ± 1.96 × erro padrão). A função do `ggpubr` para esta ação é a `ggerrorplot()` que possui múltiplos argumentos^[Para maiores detalhes: 
https://rpkgs.datanovia.com/ggpubr/reference/ggerrorplot.html]:

```{r errorplot, warning =FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barra de erro com o ggpubr", fig.pos="H"}
ggerrorplot(rnt,
             x = "sexo",
             y = "pesoRN",
             desc_stat = "mean_ci",
             color = "red",
             size = 1,
             xlab = NULL,
             ylab = "Peso dos Recém-nascidos (g)")
```

#### Incluindo múltiplos grupos

Agora, será delineado o mesmo gráfico do peso dos recém-nascidos por sexo, levando em consideração o tabagismo materno (Figura \@ref(fig:errorplot2)). Em primeiro lugar, filtra-se pelo tabagismo, presente ou ausente. Depois seguindo a mesma programação anterior, separando as cores pelo tabagismo (`fumo`). Coloca-se também o argumento `position = position_dodge (0.4)` para que não haja sobreposição das barras no gráfico, exibe-se a legenda (`show.legend = TRUE`) e coloca-se um rótulo adequado no eixo *y* e suprime-se o do eixo *x* com os argumentos `ylab` e `xlab`, respectivamente:

```{r errorplot2, warning =FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barra de erro com o ggpubr", fig.pos="H"}
rnt %>% 
  ggplot(aes(x = sexo, y = pesoRN, color = fumo)) +
  ylab("Peso do Recém-nascido (g)") +
  xlab("") +
  geom_point(stat = "summary",
             fun = "mean",
             position = position_dodge(0.4),
             size = 3,
             show.legend = TRUE) +
  geom_errorbar(stat = "summary", 
                fun.data = "mean_ci",
                width = 0.1,
                show.legend = TRUE,
                position = position_dodge(0.4))
```

### Modificação do tema

O tema padrão do `ggplot2` tem uma aparência acinzentada que pode ser modificada pela definição de outro tema integrado, como o `theme_bw()`, Figura \@ref(fig:boxbw), que é uma variação de `theme_grey()`, que usa um fundo branco e linhas finas de grade cinza. Outro tema interessante é o `theme_classic()` que é um tema de aparência clássica, com linhas dos eixos *x* e *y* e sem linhas de grade. Para ver outras possibilidades acesse https://ggplot2.tidyverse.org/reference/ggtheme.html. 
Será repetido o boxplot criado anteriormente, acrescentando rótulos mais adequados, usando os argumentos `xlab` e `ylab`, cores aos boxplots , o `theme_bw` e remover a legenda com a função `theme(legend.position=”none”)`, pois os sexos já estão explícitos.

```{r boxbw, warning =FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Boxplot dos pesos dos recém-nascidos, usando tema theme_bw()", fig.pos="H"}
 ggplot(data = rnt) +
   geom_boxplot(aes(x = sexo, 
                   y = pesoRN,
                   color = sexo)) +
   xlab ("") +
   ylab ("Peso do Recém-nascido (g)") +
   theme_bw() +
   theme(legend.position = "none")
```


### Reta de ajuste em um gráfico de dispersão

No `ggplot2`, para incluir uma reta de ajuste, acrescenta-se uma nova camada `geom_smooth()`, além da camada `geom_point()`. O argumento `method = "lm"` irá ajustar uma reta aos pontos. Também é possível colocar um intervalo de mais ou menos um erro padrão para a reta com o argumento `se = TRUE`. No exemplo da Figura \@ref(fig:point7), foi usado `se = FALSE`. Além disso, foi solicitado que cor da reta seja preta (`color = "black"`), reduzido o seu tamanho (`size = 0.5`) e estabelecido que a reta seja tracejada (`linetype = "dashed"`) ^[Para outras opções do tipo de linha, pode-se usar a função `show_lines_types()` do pacote `ggpubr`].

```{r point7, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dispersão com reta de ajuste", fig.pos="H"}
ggplot(data = rnt, 
       aes(x = compRN, y = pesoRN)) + 
  geom_point(color = "tomato", 
             size = 3) +
  geom_smooth(method = "lm", 
              se = FALSE, 
              color = "black", 
              linewidth = 0.5,
              linetype = "dashed") +
  xlab("Comprimento do Recém-nascido (cm)") +
  ylab("Peso do Recém-nascido (g)") +
  theme_bw()
```

Quando se usa mais de um `geom`, é importante a ordem em que eles são escritos, pois, como cada um deles é uma camada, elas se sobrepõem e podem se confundir.  
### Filtrando dados para o gráfico  

Faz-se isso, usando a função `filter()` do pacote `dplyr`. Será construído um gráfico igual ao anterior, filtrando apenas o sexo masculino (Figura \@ref(fig:point8)):

```{r point8, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dispersão com reta de ajuste para o sexo masculino", fig.pos="H"}
rnt %>% filter (sexo == "masc") %>%
  ggplot(aes(x = compRN, y = pesoRN)) + 
  geom_point(color = "steelblue", 
             size = 3) +
  geom_smooth(method = "lm", 
              se = FALSE, 
              color = "black", 
              linewidth = 0.5,
              linetype = "dashed") +
  xlab("Comprimento do Recém-nascido (cm)") +
  ylab("Peso do Recém-nascido (g)") +
  theme_bw()

```

### Trabalhando com os eixos no ggplot2

#### Rótulo dos eixos 

Em algumas seções anteriores, os rótulos dos eixos foram acrescentados, usando as funções `xlab()` e `ylab()`. Entretanto, como é muito comum no R, outra função, denominada `labs()`, permite adicionar os rótulos dos eixos *x* e *y*. 
 A Figura \@ref(fig:point8), usando a função `labs()` teria os seguintes comandos:

```{r eval=FALSE, echo=FALSE}
rnt %>% filter (sexo == "masc") %>%
  ggplot(aes(x = compRN, y = pesoRN)) + 
  geom_point(color = "steelblue", 
             size = 3) +
  geom_smooth(method = "lm", 
              se = FALSE, 
              color = "black", 
              linewidth = 0.5,
              linetype = "dashed") +
  labs( x = "Comprimento do Recém-nascido (cm)", 
        y = "Peso do Recém-nascido (g)") +
  theme_bw()
```

#### Acrescentando um título

O título pode ser adicionado através da função `ggtitle()`. Se for usado os dados, usados para a criação do hgráfico de linha, chega-se ao resultado da Figura \@ref(fig:titulo)

```{r titulo, out.width="80%", out.height="80%", fig.align="center", fig.cap="Mortes por COVID - RS, 2020-22", fig.pos="H"}
 ggplot(data = obitos) +
   geom_line(aes(x = data, y = obitos)) +
     labs(x = "Data(ano/mês)",
          y = "Nº de mortes") +
   ggtitle("Mortes por COVID-19 - SES/RS, 2020-22") +
   theme_bw()
```

Uma outra maneira de colocar título, subtítulo e fonte no gráfico é mostrada nos comandos da Figura \@ref(fig:subtitulo):

```{r subtitulo, out.width="80%", out.height="80%", fig.align="center", fig.cap="Mortes por COVID - RS, 2020-22", fig.pos="H"}
 ggplot(data = obitos) +
   geom_line(aes(x = data, 
                y = obitos)) +
   labs(x = "Data (ano/mês)", 
       y = "Nº de mortes",
       title = "Mortes por COVID-19",
       subtitle = "RS - 2020-2022",
       caption = "Fonte: SES") +
   theme_classic()
```

#### Outro exemplo modificando o tamanho, estilo e fonte

Esta ação é realizada, acrescentando uma camada com componentes da função `theme()`: `plot.title`, `plot.subtitle`, etc.^[Para maiores detalhes consulte:  https://tidyverse.github.io/ggplot2-docs/reference/theme.html.]  

Os dados para o exemplo são os do conjunto de dados rnt, criado anteriormente, usando, agora a função `theme()`na construção da Figura \@ref(fig:fonte):

```{r fonte, message=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Boxplots com elementos dos textos modificados", fig.pos="H"}
ggplot(data = rnt, 
       aes(x = sexo, y = pesoRN, color = sexo)) +
  geom_errorbar(stat = "boxplot", 
                width = 0.1) +
  geom_boxplot() +
  labs(x = "", 
       y = "Peso do recém-nascido (g)",
       title = "Maternidade do HGCS",
       subtitle = "Caxias do Sul, RS, 2008",
       caption = "Fonte: Autor") +
  theme_bw() +
  theme (plot.title = element_text(size = 14, 
                                   face = "bold"),
         plot.subtitle = element_text(size = 12, 
                                      face = "bold", 
                                      color = "darkgreen")) +
  theme(legend.position = "none")
```

#### Modificação dos limites dos eixos

O sistema de coordenadas cartesianas é o tipo de sistema de coordenadas mais familiar e comum. Definir limites no sistema de coordenadas ampliará o gráfico (como se você estivesse olhando para ele com uma lupa) e não alterará os dados subjacentes, como definir limites em uma escala. Para realizar este trabalho, se fará uso da função `coord_cartesian ()` ou `scale_y_continuous ()` ou `scale_x_continuous ()`.

Tomando o gráfico, já construído acima (Figura \@ref(fig:point7)) com pequenas alteraçõese e armazenando-o em um objeto, denominado `gd` (gráfico de dipersão), isto facilita a repetição do gráfico em outros códigos, pois basta escrever `gd` e executar (Figura \@ref(fig:gd)).

```{r gd, message=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dispersão", fig.pos="H"}
gd <- ggplot(data = rnt, aes(x = compRN, y = pesoRN)) + 
  geom_point(color = "tomato", 
             size = 3) +
  geom_smooth(method = "lm", 
              se = FALSE, 
              color = "black", 
              linewidth = 0.8,
              linetype = "dashed") +
  labs(x = "Comprimento do RN (cm)", y = "Peso do RN (g)",
       title = "Gráfico de Dispersão",
       caption = "Fonte: Autor") +
  theme_classic()
gd
```

1. *Função `coord_cartesian()`*
   - *xlim, ylim*  $\longrightarrow$ limites dos eixos `x` e `y`
   - *expand*  $\longrightarrow$ Se `TRUE`, o padrão, adiciona um pequeno fator de expansão aos limites para garantir que dados e eixos não se sobreponham. Se `FALSE`, os limites são tirados exatamente dos dados ou `xlim`/`ylim` (Figura \@ref(fig:zoom)).


```{r zoom, message=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dispersão expandido", fig.pos="H"}
gd + coord_cartesian(ylim = c(3000, 4000),
                     xlim = c(45, 55),
                     expand = TRUE)
```

   > Observe que é como se fizesse um zoom no gráfico nos limites estabelecidos. Há um corte um pouco acima dos limites. No eixo `y`, um pouco acima de 4000 e um pouco abaixo de 3000 e, no eixo `x`, um pouco à esquerda de 45 e um pouco à direita de 55. Isto aconteceu, porque colocamos `expand = TRUE`. Para extrair esta margem, colocar `expand = FALSE`:

2. *Usando escalas de posição contínuas*
   - Pode-se usar a função `scale_y_continous()` e `scale_x_continuous()` para fazer algo parecido com a `coord_cartesian()` (Figura \@ref(fig:zoom1)):

```{r zoom1, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de dispersão expandido", fig.pos="H"}
gd + scale_x_continuous(limits = c(45, 55)) +
  scale_y_continuous (limits = c(3500, 4000))
```

> A função removeu os casos que estão fora dos limites estabelecidos. No caso, a mensagem do R mostra que foram removidos 857 casos. O gráfico foi construido sem estes casos e, no gráfico anterior, houve apenas uma aproximação (um zoom) dentro dos limites. Portanto, houve um impacto importante no gráfico.  
> Se os dados não forem em escala contínua, é possível escolher outra escala, por esxemplo `scale_y_discrete ()`.

#### Modificando a expansão  

É possível intervir na expansão da margem com o argumento `expand = TRUE` ou `FALSE` que pode ser usado também com a função `scale_y_continuous()`.Será visto um exemplo de um gráfico de barras das faixas etárias das gestantes (Figura \@ref(fig:axis)):

```{r axis, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barras", fig.pos="H"}
gb <- ggplot(data = rnt) +
  geom_bar(aes(x = categIdade, 
               y = after_stat(count/sum(count))),
           show.legend = FALSE) +
  labs(y = "Frequência", 
       x = "Faixa Etária da Parturiente") +
  theme_bw()
gb
```

Observe que abaixo do 0 (zero) existe uma expansão. Para que as barras tenham início exatamente no 0, pode-se empregar a função `scale_y_continuous()` com o argumento `expand = expansion (add = c(0,50))`, significando que não se expande nada abaixo do 0 e se adiciona 50 unidades para cima, criando uma margem superior (Figura \@ref(fig:axis1)). 

```{r axis1, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barras com expansão", fig.pos="H"}
gb + scale_y_continuous (expand = expansion(add = c(0,0.05)))
```

Isto também poderia ser feito com `mult` no lugar do `add` (Figura \@ref(fig:axis2)), representando o multiplicador que se coloca acima e abaixo:

```{r axis2, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barras, igual a anterior", fig.pos="H"}
gb + scale_y_continuous (expand = expansion(mult = c(0,0.05)))
```

#### Usando a proporção ou percentagem nos eixos  

Na Figura \@ref(fig:axis), a unidade do eixo *y* encontra-se como um proporção `y = after_stat(count/sum(count)`. É possível modificar para percentagem (Figura \@ref(fig:percent)), empregando a função `percent_format()` do pacote `scales` [@wickman2022scales]:  

```{r percent, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barras com percentagens no eixo y", fig.pos="h"}
gb + scale_y_continuous (expand = expansion(mult = c(0,0.05)),
                         labels = percent_format (accuracy = 0.1,
                                                   decimal.mark = ","))
```

#### Mudando o nome e a ordem dos rótulos do eixo x

No gráfico acima, temos a faixa etária dividida em `<20a`, `20-35a` e `>35a`. Pode haver interesse em mudar para `adolescentes`, `adultas jovens` e `gestante idosa` (Figura \@ref(fig:label)). Para fazer isso, sem modificar o banco de dados, simplemente altera-se-se os rótulos no argumento `labels` da função `scale_x_discrete()`:

```{r label, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barras com eixo x modificado", fig.pos="H"}
gb + 
  scale_y_continuous (expand = expansion(mult = c(0,0.05)),
                      labels = percent_format (accuracy = 0.1,
                                               decimal.mark = ",")) +
  scale_x_discrete (labels = c("Adolescente", 
                               "Adulta jovem", 
                               "Gestante idosa"))
```

Para mudar a ordem dos nomes do eixo x, usando a ordem decrescente da frequência, basta colocar na função scale_x_discrete os argumentos limits e labels com a ordem desejada. O resultado é a Figura \@ref(fig:ordem).

```{r ordem, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barras com eixo x modificado", fig.pos="H"}
gb + scale_x_discrete (limits = c("20-35a", "<20a", ">35a"),
                    labels = c("Adulta jovem", "Adolescente", "Gestante idosa"))
```

#### Moficação dos intervalos dos valores do eixo

O gráfico de linha de mortes por COVID no RS, 2020-2022, visto anteriormente (Figura \@ref(fig:ggline)), será atribuído a um objeto `gl`:

```{r linha, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Mortes por COVID-19, 2020-2022, RS.", fig.pos="H"}
gl <- ggplot(data = obitos) +
  geom_line(aes(x = data, y = obitos)) +
  labs(x = "Ano (mês)", y = "Nº de mortes") +
  theme_classic()
gl
```

Observe (Figura \@ref(fig:linha)) que, no eixo *y*, os óbitos estão registrados a cada 2000 e, no eixo *x*, foram marcadas apenas 4 datas. Podemos modificar isso adicionando duas camadas, usando as funções `scale_y_continuous()` e `scale_x_datetime()`:

```{r linha1, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Mortes por COVID-19, 2020-2022, RS.", fig.pos="H"}
gl + scale_y_continuous(n.breaks = 10) +
  scale_x_datetime(date_breaks = "4 month",
                   date_labels = "%Y (%b)")
```

O aspecto do gráfico mudou um pouco (Figura \@ref(fig:linha1)). Agora, existem marcações no eixo *y* a cada 1000 mortes e o registro do tempo aparece a cada 4 meses, conforme estabelecido no argumento `date_breaks = "4 month"` e o formato foi modificado com o argumento `date_labels = "%Y %b"`. Neste, `%Y` significa o ano e `%b` significa o mês abreviado (Jan-Dec). Para ver como customizar as datas, veja [**aqui**](https://www.r-bloggers.com/2018/06/customizing-time-and-date-scales-in-ggplot2/)

### Modificação das cores  

Voltando a usar um gráfico de barra, já visto anteriormente (Figura \@ref(fig:ggbar)), da distribuição da idade da gestante por faixa etária (`categIdade`), onde o `ggplot2` escolheu as cores das barras de acordo com o seu padrão.  

Entretanto, a cor ou cores das barras podem ser modificadas na estética relacionada à cor: `color` ou `colour`, `fill` e `alpha`. Estes parâmetros estéticos alteram a cor (`colour` e `fill`) e a transparência (`alpha`). A mudança nas cores é uma forma de aprimorar um gráfico, especialmente quando representa mais de duas variáveis.  

Uma cor pode ser especificada por seu nome em inglês (por exemplo, “red”, “steelblue”). O R possui 657 cores integradas ^[As cores podem ser consultadas na folha de R Colors da Universidade de Columbia, criada pelo Dr. Ying Wei ( http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf] que permitem uma ampla escolha. Uma outra maneira de especificar as cores é usar o sistema RGB  ou hexadecimal. O código hexadecimal da cor branca é #FFFFFFF, da "gray58" é  #949494,  da "yellow4" é #999900, etc. Opcionalmente, a cor pode ser transparente, usando o formato "#RRGGBBAA".
`Alpha` refere-se à opacidade de um geom. Os valores de `alpha` variam de 0 a 1, com valores mais baixos correspondendo a cores mais transparentes. `Alpha` também pode ser modificada por meio da estética de `colour` ou `fill` se qualquer uma das estéticas fornecer valores de cor usando uma especificação RGB.

#### Usando uma única cor

A Figura \@ref(fig:ggbar) será modificada, usando a cor cinza-claro para o preenchimento das barras (`fill = “gray80”`) e vermelho-escuro para bordas das barras (`color = “darkred”`), colocados fora da `aes`. Após a execução dos códigos, o resultado será a Figura \@ref(fig:cor).

```{r cor, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Frequência da faixa etária das parturientes da Maternidade do HCCS, 2008.", fig.pos="H"}
ggplot(data = rnt) +
  geom_bar(aes(x = categIdade, 
               y = after_stat(count/sum(count))),
           fill = "gray80",
           colour = "darkred",
           show.legend = FALSE) +
  labs(y = "Frequência",
       x = "Faixa Etária") +
  scale_y_continuous(expand = expansion(mult = c(0,0.05)),
                     labels = percent_format (accuracy = 0.1,
                                              decimal.mark = ",")) +
  theme_bw()
```

#### Cores diferentes de acordo com o grupo

Continuando com os mesmos dados, o preenchimento (`fill = categIdade`) será colocado dentro da `aes` e o `ggplot2` escolhe as cores do sua paleta, conforme o número de categorias. As bordas serão mantidas na mesma cor, `color = darkred`, permanecendo fora da aes. Saida da execução dos comandos resultará na Figura \@ref(fig:cor1).

```{r cor1, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Cores estabelecidas por fill = grupo", fig.pos="H"}
ggplot(data = rnt) +
  geom_bar(aes(x = categIdade, 
               y = after_stat(count/sum(count)),
               fill = categIdade),
           colour = "darkred",
           show.legend = FALSE) +
  labs(y = "Frequência",
       x = "Faixa Etária") +
  scale_y_continuous(expand = expansion(mult = c(0,0.05)),
                     labels = percent_format (accuracy = 0.1,
                                              decimal.mark = ",")) +
  theme_bw()
```

#### Mudanças das cores manualmente

As cores da Figura \@ref(fig:cor1) ficaram um pouco espalhafatosas para o gosto do autor e serão modificadas, usando a função `scale_fill_manual()`. As barras assumirão cores salmão em tons diferentes e as bordas serão pretas. A escolha das cores é pessoal. Assim, resultará em um gráfico como o da Figura \@ref(fig:cor2).

```{r cor2, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Cores de escolha pessoal", fig.pos="H"}
ggplot(data = rnt) +
  geom_bar(aes(x = categIdade, 
               y = after_stat(count/sum(count)),
               fill = categIdade),
           colour = "black",
           show.legend = FALSE) +
  labs(y = "Frequência",
       x = "Faixa Etária") +
  scale_y_continuous(expand = expansion(mult = c(0,0.05)),
                     labels = percent_format (accuracy = 0.1,
                                              decimal.mark = ",")) +
  scale_fill_manual(values = c("lightsalmon1", "lightsalmon3",  
                               "lightsalmon4")) +
  theme_bw()
```

#### Cores de acordo com uma determinada paleta

O `ggsci` é um pacote que oferece uma coleção de paletas de alta qualidade inspiradas em cores usadas em revistas científicas, bibliotecas de visualização de dados, filmes de ficção científica e programas de TV. As paletas de cores no ggsci estão disponíveis como escalas `ggplot2`. Para todas usa-se as seguintes funções: `scale_color_palname()` e `scale_fill_palname()`. Por exemplo, para a paleta do Lancet, usa-se para o preenchimento: `scale_fill_lancet()` . O pacote `ggsci` deve ser instalado e carregado para usar estas paletas.
A  Figura \@ref(fig:cor3) mostra a modificação das cores conforme a paleta  do periódico Lancet.

```{r cor3, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Cores conforme a paleta do Lancet", fig.pos="H"}
 ggplot(data = rnt) +
  geom_bar(aes(x = categIdade, 
               y = after_stat(count/sum(count)),
               fill = categIdade),
           show.legend = FALSE) +
  labs(y = "Frequência",
       x = "Faixa Etária") +
  scale_y_continuous(expand = expansion(mult = c(0,0.05)),
                     labels = percent_format (accuracy = 0.1,
                                              decimal.mark = ",")) +
  scale_fill_lancet() +
  theme_bw()
```


### Exemplo final: Gráfico de barra de erro com colunas

Um gráfico de barras de erro será usado para visualizar a influência do sexo e do tabagismo materno no peso do recém-nascido. Será incluído a representação das colunas (barras) e as barras de erro com intervalo de confiança de 95%, calculado usando média ± margem de erro, onde a margem de erro = 1.96 × erro padrão. Estes conceitos serão discutidos adiante no Capítulo \@ref(sec-estimacao). 

#### Resumo dos dados usados

Em primeiro lugar, faz-se um resumo dos dados que serão usados no gráfico:

```{r message=FALSE}
resumo <- rnt %>% 
  group_by(sexo, fumo) %>% 
  dplyr::summarise(n = n(),
                   media = mean(pesoRN, na.rm = TRUE),
                   dp = sd(pesoRN, na.rm = TRUE),
                   me = 1.96 * dp/sqrt(n))
resumo
```

Onde, `dp = desvio padrão` e `me = margem de erro`. O objeto `resumo` pertence a classe `data.frame` e será empregado na construção do gráfico.

#### Gráfico de barra de erro

Inicialmente se constrói, usando o dataframe resumo, um gráfico de barra. A seguir, acrescenta-se outra camada para incluir a barra de erro. Em sequência, coloca-se os rótulos; a função `scale_y_continous()` coloca o início das barras em zero e as cores são manualmente colocadas conforme a escolha do autor  (Figura \@ref(fig:final)).
Observe que o rótulo da legenda, na função `labs()`, foi determinado com `fill = "Tabagismo"`, porque as cores das barras foram estabelecidas na estética do ggplot com o mesmo argumento (`fill = fumo`).

```{r final, warning=FALSE, out.width="80%", out.height="80%", fig.align="center", fig.cap="Gráfico de barra de erro no ggplot2", fig.pos="H"}
ggplot(resumo, 
           aes(x=sexo, y=media, fill=fumo)) + 
  geom_bar(stat="identity", color="black", 
           position=position_dodge()) +
  geom_errorbar(aes(ymin=media-0, ymax=media+me), width=.2,
                position=position_dodge(.9)) +
  labs(x="Sexo", 
       y = "Peso do RN (g)",
       fill = "Tabagismo",
       caption = "RN = Recém-nascido")+
  scale_y_continuous(expand = expansion(mult = c(0,0.05))) + 
  theme_classic() + 
  scale_fill_manual(values=c('gray80','darkslategray1'))
```


<br>
<br>

OBS.: Clique em [**ggplot2::cheat sheet**](https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf) para obter a planilha de dicas do `ggplot2`.
